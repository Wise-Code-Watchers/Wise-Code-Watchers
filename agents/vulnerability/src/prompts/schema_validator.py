"""
JSON Schema Validator for WiseCodeWatchers structured output.

Validates agent-generated JSON reports against the official schema.
"""

import json
import logging
import os
from typing import Dict, Any, Optional, Tuple

logger = logging.getLogger(__name__)


# Simple JSON schema validator (without requiring jsonschema package)
class SchemaValidator:
    """Validate JSON reports against the WiseCodeWatchers schema."""

    def __init__(self, schema_path: Optional[str] = None):
        """
        Initialize validator with schema.

        Args:
            schema_path: Path to schema JSON file. If None, uses default path.
        """
        if schema_path is None:
            # Default path relative to this file
            schema_path = os.path.join(
                os.path.dirname(__file__),
                "report_schema.json"
            )

        self.schema = self._load_schema(schema_path)
        self._compile_validators()

    def _load_schema(self, schema_path: str) -> Dict[str, Any]:
        """Load schema from JSON file."""
        try:
            with open(schema_path, "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            logger.warning(f"Schema file not found: {schema_path}")
            return {}
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON in schema file: {e}")
            return {}

    def _compile_validators(self):
        """Compile efficient validators from schema."""
        # Pre-compile validation rules for faster execution
        self.required_fields = set(self.schema.get("required", []))
        self.property_schemas = self.schema.get("properties", {})

        # Finding schema
        finding_def = self.schema.get("$defs", {}).get("finding", {})
        self.finding_required = set(finding_def.get("required", []))
        self.finding_categories = set(
            finding_def.get("properties", {})
            .get("category", {})
            .get("enum", [])
        )
        self.severity_enum = set(
            finding_def.get("properties", {})
            .get("severity", {})
            .get("enum", [])
        )
        self.confidence_enum = set(
            finding_def.get("properties", {})
            .get("confidence", {})
            .get("enum", [])
        )

        # Suggestion schema
        suggestion_def = self.schema.get("$defs", {}).get("suggestion", {})
        self.suggestion_required = set(suggestion_def.get("required", []))
        self.suggestion_types = set(
            suggestion_def.get("properties", {})
            .get("type", {})
            .get("enum", [])
        )

    def validate(self, report: Dict[str, Any]) -> Tuple[bool, list]:
        """
        Validate a complete report against schema.

        Args:
            report: Report dictionary to validate

        Returns:
            Tuple of (is_valid, error_messages)
        """
        errors = []

        # Check required top-level fields
        for field in self.required_fields:
            if field not in report:
                errors.append(f"Missing required field: {field}")

        # Validate tool
        if "tool" in report and report["tool"] != "WiseCodeWatchers":
            errors.append(f"Invalid tool value: {report['tool']}")

        # Validate pr section
        if "pr" in report:
            pr_errors = self._validate_pr(report["pr"])
            errors.extend(pr_errors)

        # Validate summary
        if "summary" in report:
            summary_errors = self._validate_summary(report["summary"])
            errors.extend(summary_errors)

        # Validate findings
        if "findings" in report:
            if not isinstance(report["findings"], list):
                errors.append("findings must be a list")
            else:
                for i, finding in enumerate(report["findings"]):
                    finding_errors = self._validate_finding(finding, index=i)
                    errors.extend(finding_errors)

        # Validate non_blocking_suggestions
        if "non_blocking_suggestions" in report:
            if not isinstance(report["non_blocking_suggestions"], list):
                errors.append("non_blocking_suggestions must be a list")
            else:
                for i, suggestion in enumerate(report["non_blocking_suggestions"]):
                    suggestion_errors = self._validate_suggestion(suggestion, index=i)
                    errors.extend(suggestion_errors)

        is_valid = len(errors) == 0
        return is_valid, errors

    def _validate_pr(self, pr: Dict[str, Any]) -> list:
        """Validate PR section."""
        errors = []
        required = ["repo", "number", "base_sha", "head_sha"]

        for field in required:
            if field not in pr:
                errors.append(f"pr.{field} is required")

        return errors

    def _validate_summary(self, summary: Dict[str, Any]) -> list:
        """Validate summary section."""
        errors = []
        required = ["security_issues", "logic_issues", "maintainability_issues",
                    "highest_severity", "notes"]

        for field in required:
            if field not in summary:
                errors.append(f"summary.{field} is required")

        # Validate severity enum
        if "highest_severity" in summary:
            valid_severities = {"NONE", "LOW", "MEDIUM", "HIGH", "CRITICAL"}
            if summary["highest_severity"] not in valid_severities:
                errors.append(f"Invalid summary.highest_severity: {summary['highest_severity']}")

        return errors

    def _validate_finding(self, finding: Dict[str, Any], index: int) -> list:
        """Validate a single finding."""
        errors = []
        prefix = f"findings[{index}]"

        # Check required fields
        for field in self.finding_required:
            if field not in finding:
                errors.append(f"{prefix}.{field} is required")

        # Validate category enum
        if "category" in finding and finding["category"] not in self.finding_categories:
            errors.append(f"{prefix}.category invalid: {finding['category']}")

        # Validate severity enum
        if "severity" in finding and finding["severity"] not in self.severity_enum:
            errors.append(f"{prefix}.severity invalid: {finding['severity']}")

        # Validate confidence enum
        if "confidence" in finding and finding["confidence"] not in self.confidence_enum:
            errors.append(f"{prefix}.confidence invalid: {finding['confidence']}")

        # Validate evidence structure
        if "evidence" in finding:
            evidence = finding["evidence"]
            if not isinstance(evidence, dict):
                errors.append(f"{prefix}.evidence must be an object")
            else:
                if "code_excerpt" not in evidence:
                    errors.append(f"{prefix}.evidence.code_excerpt is required")
                if "reasoning" not in evidence:
                    errors.append(f"{prefix}.evidence.reasoning is required")

        return errors

    def _validate_suggestion(self, suggestion: Dict[str, Any], index: int) -> list:
        """Validate a single suggestion."""
        errors = []
        prefix = f"non_blocking_suggestions[{index}]"

        # Check required fields
        for field in self.suggestion_required:
            if field not in suggestion:
                errors.append(f"{prefix}.{field} is required")

        # Validate type enum
        if "type" in suggestion and suggestion["type"] not in self.suggestion_types:
            errors.append(f"{prefix}.type invalid: {suggestion['type']}")

        return errors


def parse_and_validate_llm_output(
    raw_output: str,
    validator: Optional[SchemaValidator] = None
) -> Tuple[Optional[Dict[str, Any]], list]:
    """
    Parse LLM output as JSON and validate against schema.

    Args:
        raw_output: Raw string output from LLM
        validator: Optional SchemaValidator instance. If None, creates new one.

    Returns:
        Tuple of (parsed_report, error_messages)
        - parsed_report is None if parsing or validation fails
    """
    errors = []

    if validator is None:
        validator = SchemaValidator()

    # Clean output - remove markdown code blocks
    cleaned = raw_output.strip()

    # Remove ```json and ``` markers
    if cleaned.startswith("```json"):
        cleaned = cleaned[7:]
    elif cleaned.startswith("```"):
        cleaned = cleaned[3:]

    if cleaned.endswith("```"):
        cleaned = cleaned[:-3]

    cleaned = cleaned.strip()

    # Try to parse JSON
    try:
        report = json.loads(cleaned)
    except json.JSONDecodeError as e:
        errors.append(f"JSON parsing failed: {str(e)}")
        # Try to extract JSON object from mixed content
        start = cleaned.find("{")
        end = cleaned.rfind("}") + 1
        if start != -1 and end > start:
            try:
                report = json.loads(cleaned[start:end])
                errors.append("Warning: JSON extracted from mixed content")
            except json.JSONDecodeError:
                errors.append("Failed to extract valid JSON from output")
                return None, errors
        else:
            return None, errors

    # Validate against schema
    is_valid, validation_errors = validator.validate(report)
    errors.extend(validation_errors)

    if not is_valid:
        logger.warning(f"Schema validation failed with {len(errors)} errors")
        return report, errors  # Return report even if validation fails, for debugging

    return report, []


def validate_auto_downgrade_rules(report: Dict[str, Any]) -> Tuple[Dict[str, Any], list]:
    """
    Apply auto-downgrade rules to filter out low-confidence findings.

    Args:
        report: Validated report dictionary

    Returns:
        Tuple of (filtered_report, downgraded_items)
        - downgraded_items: List of items that were downgraded
    """
    downgraded = []

    findings = report.get("findings", [])
    filtered_findings = []
    suggestions = report.get("non_blocking_suggestions", [])

    for finding in findings:
        # Rule 1: LOW confidence -> downgrade to suggestion
        if finding.get("confidence") == "LOW":
            downgraded.append({
                "item": finding,
                "reason": "LOW confidence",
                "action": "moved to non_blocking_suggestions"
            })
            # Convert to suggestion
            suggestions.append({
                "type": "DEFENSIVE_HARDENING",
                "title": finding.get("title", "Low confidence issue"),
                "details": finding.get("evidence", {}).get("reasoning", ""),
                "file": finding.get("file", ""),
                "line_start": finding.get("line_start", 0),
                "line_end": finding.get("line_end", 0)
            })
            continue

        # Rule 2: Check for nil/NoMethodError without proper evidence
        title = finding.get("title", "").lower()
        desc = finding.get("evidence", {}).get("reasoning", "").lower()

        if ("nil" in title or "nomethoderror" in title or "null" in title):
            # Check if it meets nil criteria (requires explicit evidence)
            evidence = finding.get("evidence", {})
            has_reachable_path = (
                "controller" in desc or
                "route" in desc or
                "job" in desc or
                "service" in desc or
                "execution path" in desc
            )

            if not has_reachable_path:
                downgraded.append({
                    "item": finding,
                    "reason": "Nil/NoMethodError without reachable execution path",
                    "action": "moved to non_blocking_suggestions"
                })
                suggestions.append({
                    "type": "DEFENSIVE_HARDENING",
                    "title": finding.get("title", "Potential nil handling"),
                    "details": finding.get("evidence", {}).get("reasoning", ""),
                    "file": finding.get("file", ""),
                    "line_start": finding.get("line_start", 0),
                    "line_end": finding.get("line_end", 0)
                })
                continue

        # Keep high-quality findings
        filtered_findings.append(finding)

    # Build filtered report
    filtered_report = report.copy()
    filtered_report["findings"] = filtered_findings
    filtered_report["non_blocking_suggestions"] = suggestions

    # Update summary counts
    summary = filtered_report.get("summary", {})
    security_count = sum(1 for f in filtered_findings if f.get("category") == "SECURITY")
    logic_count = sum(1 for f in filtered_findings if f.get("category") == "LOGIC")
    maintainability_count = sum(1 for f in filtered_findings if f.get("category") == "MAINTAINABILITY")

    summary["security_issues"] = security_count
    summary["logic_issues"] = logic_count
    summary["maintainability_issues"] = maintainability_count

    # Update highest severity
    if filtered_findings:
        severity_order = {"CRITICAL": 4, "HIGH": 3, "MEDIUM": 2, "LOW": 1}
        max_severity = max(
            filtered_findings,
            key=lambda f: severity_order.get(f.get("severity", "LOW"), 0)
        )
        summary["highest_severity"] = max_severity.get("severity", "NONE")
    else:
        summary["highest_severity"] = "NONE"

    filtered_report["summary"] = summary

    return filtered_report, downgraded
