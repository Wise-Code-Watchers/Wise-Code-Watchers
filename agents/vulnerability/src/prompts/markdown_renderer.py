"""
JSON-to-Markdown Renderer for WiseCodeWatchers.

Converts validated JSON reports to GitHub-friendly markdown format.
"""

from typing import Dict, Any, List


def render_comprehensive_review(report: Dict[str, Any]) -> str:
    """
    Render a validated JSON report as GitHub markdown.

    Args:
        report: Validated report dictionary following the schema

    Returns:
        Markdown string suitable for GitHub PR comments
    """
    lines = []

    # Header
    lines.append("## ðŸ” WiseCodeWatchers Comprehensive Review\n")

    # Summary section
    summary = report.get("summary", {})
    lines.append(_render_summary(summary))

    # Findings by category
    findings = report.get("findings", [])

    # Security Issues
    security_findings = [f for f in findings if f.get("category") == "SECURITY"]
    if security_findings:
        lines.append("\n### ðŸ”’ Security Issues\n")
        for finding in security_findings[:10]:  # Limit to 10 for readability
            lines.append(_render_finding(finding))
        if len(security_findings) > 10:
            lines.append(f"\n*...and {len(security_findings) - 10} more security issues*")

    # Logic Issues
    logic_findings = [f for f in findings if f.get("category") == "LOGIC"]
    if logic_findings:
        lines.append("\n### ðŸ§  Logic Issues\n")
        for finding in logic_findings[:10]:
            lines.append(_render_finding(finding))
        if len(logic_findings) > 10:
            lines.append(f"\n*...and {len(logic_findings) - 10} more logic issues*")

    # Maintainability Issues
    maintainability_findings = [f for f in findings if f.get("category") == "MAINTAINABILITY"]
    if maintainability_findings:
        lines.append("\n### ðŸ”§ Maintainability Issues\n")
        for finding in maintainability_findings[:5]:
            lines.append(_render_finding(finding))
        if len(maintainability_findings) > 5:
            lines.append(f"\n*...and {len(maintainability_findings) - 5} more maintainability issues*")

    # Non-blocking suggestions
    suggestions = report.get("non_blocking_suggestions", [])
    if suggestions:
        lines.append("\n### ðŸ’¡ Recommendations\n")

        # Group by type
        suggestions_by_type = _group_suggestions(suggestions)

        for suggestion_type, type_suggestions in suggestions_by_type.items():
            if type_suggestions:
                lines.append(f"\n#### {suggestion_type}\n")
                for suggestion in type_suggestions[:5]:
                    lines.append(_render_suggestion(suggestion))
                if len(type_suggestions) > 5:
                    lines.append(f"*...and {len(type_suggestions) - 5} more*")

    # Footer
    lines.append("\n---\n")
    lines.append("*Generated by [WiseCodeWatchers](https://github.com/your-org/WiseCodeWatchers)*")

    return "\n".join(lines)


def _render_summary(summary: Dict[str, Any]) -> str:
    """Render summary section."""
    lines = ["### ðŸ“Š Summary\n"]

    # Summary table
    lines.append("| Metric | Value |")
    lines.append("|--------|-------|")
    lines.append(f"| Security Issues | {summary.get('security_issues', 0)} |")
    lines.append(f"| Logic Issues | {summary.get('logic_issues', 0)} |")
    lines.append(f"| Maintainability Issues | {summary.get('maintainability_issues', 0)} |")
    lines.append(f"| **Total Issues** | **{summary.get('security_issues', 0) + summary.get('logic_issues', 0) + summary.get('maintainability_issues', 0)}** |")

    # Highest severity badge
    highest_severity = summary.get("highest_severity", "NONE")
    severity_badges = {
        "CRITICAL": "ðŸ”´ **CRITICAL**",
        "HIGH": "ðŸŸ  **HIGH**",
        "MEDIUM": "ðŸŸ¡ **MEDIUM**",
        "LOW": "ðŸŸ¢ **LOW**",
        "NONE": "âœ… **NONE**"
    }
    lines.append(f"| Highest Severity | {severity_badges.get(highest_severity, highest_severity)} |")
    lines.append("")

    # Notes
    notes = summary.get("notes", [])
    if notes:
        lines.append("**Notes:**")
        for note in notes:
            lines.append(f"- {note}")
        lines.append("")

    return "\n".join(lines)


def _render_finding(finding: Dict[str, Any]) -> str:
    """Render a single finding."""
    lines = []

    # Severity badge and title
    severity = finding.get("severity", "UNKNOWN")
    title = finding.get("title", "Untitled Issue")
    confidence = finding.get("confidence", "UNKNOWN")

    severity_emojis = {
        "CRITICAL": "ðŸ”´",
        "HIGH": "ðŸŸ ",
        "MEDIUM": "ðŸŸ¡",
        "LOW": "ðŸŸ¢"
    }
    emoji = severity_emojis.get(severity, "")

    lines.append(f"#### {emoji} [{severity}] {title}")
    lines.append(f"*Confidence: {confidence}*")

    # Location
    file_path = finding.get("file", "")
    line_start = finding.get("line_start", 0)
    line_end = finding.get("line_end", 0)

    if file_path:
        if line_start and line_end and line_start != line_end:
            lines.append(f"**Location:** `{file_path}:{line_start}-{line_end}`")
        elif line_start:
            lines.append(f"**Location:** `{file_path}:{line_start}`")
        else:
            lines.append(f"**Location:** `{file_path}`")

    # Evidence
    evidence = finding.get("evidence", {})
    code_excerpt = evidence.get("code_excerpt", "")

    if code_excerpt:
        lines.append("\n**Evidence:**")
        lines.append("```")
        # Truncate long code excerpts
        if len(code_excerpt) > 500:
            lines.append(code_excerpt[:500] + "\n... (truncated)")
        else:
            lines.append(code_excerpt)
        lines.append("```")

    # Trigger and Impact
    trigger = finding.get("trigger", "")
    impact = finding.get("impact", "")

    if trigger:
        lines.append(f"\n**Trigger:** {trigger}")

    if impact:
        lines.append(f"**Impact:** {impact}")

    # Recommendation
    recommendation = finding.get("recommendation", "")
    if recommendation:
        lines.append(f"\n**Recommendation:** {recommendation}")

    # Patch suggestion
    patch = finding.get("patch_suggestion", "")
    if patch:
        lines.append("\n**Suggested Fix:**")
        lines.append("```diff")
        lines.append(patch)
        lines.append("```")

    # References
    references = finding.get("references", [])
    if references:
        lines.append("\n**References:**")
        for ref in references[:3]:
            lines.append(f"- {ref}")

    # CWE/OWASP tags
    cwe = finding.get("cwe", "")
    owasp = finding.get("owasp", "")

    if cwe or owasp:
        tags = []
        if cwe:
            tags.append(f"CWE: {cwe}")
        if owasp:
            tags.append(f"OWASP: {owasp}")
        lines.append(f"\n*Tags: {', '.join(tags)}*")

    lines.append("")
    return "\n".join(lines)


def _render_suggestion(suggestion: Dict[str, Any]) -> str:
    """Render a single suggestion."""
    lines = []

    title = suggestion.get("title", "Suggestion")
    suggestion_type = suggestion.get("type", "DEFENSIVE_HARDENING")

    lines.append(f"- **{title}** ({suggestion_type})")

    details = suggestion.get("details", "")
    if details:
        # Truncate long details
        if len(details) > 200:
            details = details[:200] + "..."
        lines.append(f"  - {details}")

    # Location if available
    file_path = suggestion.get("file", "")
    line_start = suggestion.get("line_start", 0)
    line_end = suggestion.get("line_end", 0)

    if file_path and line_start:
        if line_end and line_end != line_start:
            lines.append(f"  - Location: `{file_path}:{line_start}-{line_end}`")
        else:
            lines.append(f"  - Location: `{file_path}:{line_start}`")

    return "\n".join(lines)


def _group_suggestions(suggestions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    """Group suggestions by type."""
    grouped = {}

    for suggestion in suggestions:
        suggestion_type = suggestion.get("type", "DEFENSIVE_HARDENING")

        if suggestion_type not in grouped:
            grouped[suggestion_type] = []

        grouped[suggestion_type].append(suggestion)

    # Sort types in priority order
    type_order = [
        "DEFENSIVE_HARDENING",
        "TEST_COVERAGE",
        "REFACTOR",
        "PERFORMANCE",
        "STYLE",
        "DOCS"
    ]

    sorted_grouped = {}
    for t in type_order:
        if t in grouped:
            sorted_grouped[t] = grouped[t]

    # Add any remaining types
    for t, suggestions_list in grouped.items():
        if t not in sorted_grouped:
            sorted_grouped[t] = suggestions_list

    return sorted_grouped


def render_inline_comment_from_finding(finding: Dict[str, Any]) -> str:
    """
    Render a single finding as an inline comment for GitHub.

    Args:
        finding: Single finding dictionary

    Returns:
        Short markdown string suitable for inline comment
    """
    lines = []

    severity = finding.get("severity", "UNKNOWN")
    title = finding.get("title", "Issue detected")

    severity_emojis = {
        "CRITICAL": "ðŸ”´",
        "HIGH": "ðŸŸ ",
        "MEDIUM": "ðŸŸ¡",
        "LOW": "ðŸŸ¢"
    }
    emoji = severity_emojis.get(severity, "")

    lines.append(f"**{emoji} {severity}** - {title}\n")

    # Brief evidence
    evidence = finding.get("evidence", {})
    reasoning = evidence.get("reasoning", "")

    if reasoning:
        # Truncate for inline comment
        if len(reasoning) > 300:
            reasoning = reasoning[:300] + "..."
        lines.append(f"{reasoning}")

    # Brief recommendation
    recommendation = finding.get("recommendation", "")
    if recommendation:
        if len(recommendation) > 200:
            recommendation = recommendation[:200] + "..."
        lines.append(f"\n**Fix:** {recommendation}")

    return "\n".join(lines)
