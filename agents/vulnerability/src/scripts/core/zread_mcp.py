"""
ZRead MCP 客户端 - 用于获取 GitHub 仓库内容
支持 Streamable HTTP JSON-RPC 协议
"""

import os
import json
import asyncio
from typing import Any, Dict, List, Optional
from urllib.parse import urlparse
from urllib.request import Request, urlopen
from urllib.error import URLError, HTTPError


class ZReadMCPClient:
    """
    ZRead MCP 客户端
    实现 MCP 协议与 ZRead Server 通信
    """

    def __init__(self, server_url: str, api_key: Optional[str] = None, timeout: int = 30):
        """
        初始化 MCP 客户端

        Args:
            server_url: MCP 服务器 URL (e.g., "http://localhost:3000/mcp")
            api_key: 可选的 API Key，用于 Authorization header
            timeout: 请求超时时间（秒）
        """
        self.server_url = server_url.rstrip("/")
        self.api_key = api_key
        self.timeout = timeout
        self.request_id = 0
        self._initialized = False
        self._tools_cache = None

    def _generate_request_id(self) -> int:
        """生成递增的请求 ID"""
        self.request_id += 1
        return self.request_id

    def _send_request(self, method: str, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        发送 JSON-RPC 请求

        Args:
            method: RPC 方法名
            params: 方法参数

        Returns:
            响应结果
        """
        request_id = self._generate_request_id()
        payload = {
            "jsonrpc": "2.0",
            "id": request_id,
            "method": method,
        }

        if params:
            payload["params"] = params

        try:
            # 构建 HTTP 请求
            data = json.dumps(payload).encode("utf-8")

            # 基础 headers
            headers = {
                "Content-Type": "application/json",
                "Accept": "application/json, text/event-stream",
            }

            # 如果提供了 API Key，添加 Authorization header
            if self.api_key:
                headers["Authorization"] = f"Bearer {self.api_key}"

            req = Request(
                self.server_url,
                data=data,
                headers=headers,
                method="POST",
            )

            # 发送请求
            with urlopen(req, timeout=self.timeout) as response:
                content_type = response.headers.get("Content-Type", "")
                response_data = response.read().decode("utf-8")

                # 处理不同的响应类型
                if "application/json" in content_type:
                    result = json.loads(response_data)
                elif "text/event-stream" in content_type:
                    # 处理 SSE 流式响应
                    result = self._parse_sse_response(response_data)
                else:
                    result = json.loads(response_data)

                # 检查 JSON-RPC 错误
                if "error" in result:
                    raise Exception(f"MCP Error: {result['error']}")

                return result.get("result", {})

        except HTTPError as e:
            raise Exception(f"HTTP Error: {e.code} - {e.reason}")
        except URLError as e:
            raise Exception(f"Connection Error: {e.reason}")
        except Exception as e:
            raise Exception(f"Request Failed: {str(e)}")

    def _parse_sse_response(self, data: str) -> Dict[str, Any]:
        """
        解析 Server-Sent Events 响应

        Args:
            data: SSE 响应数据

        Returns:
            解析后的结果
        """
        lines = data.strip().split("\n")
        for line in lines:
            if line.startswith("data:"):
                json_str = line[5:].strip()
                if json_str:
                    try:
                        return json.loads(json_str)
                    except json.JSONDecodeError:
                        continue
        return {}

    def initialize(self) -> bool:
        """
        初始化 MCP 连接（握手）

        Returns:
            是否初始化成功
        """
        try:
            # 发送 initialize 请求
            init_result = self._send_request(
                "initialize",
                {
                    "protocolVersion": "2024-11-05",
                    "capabilities": {},
                    "clientInfo": {
                        "name": "wise-code-watchers",
                        "version": "1.0.0"
                    }
                }
            )

            # 发送 initialized 通知
            self._send_notification("initialized")

            self._initialized = True
            print("✅ ZRead MCP 客户端初始化成功")
            return True

        except Exception as e:
            print(f"❌ ZRead MCP 初始化失败: {str(e)}")
            return False

    def _send_notification(self, method: str, params: Optional[Dict[str, Any]] = None):
        """
        发送 JSON-RPC 通知（无响应）

        Args:
            method: 通知方法名
            params: 通知参数
        """
        payload = {
            "jsonrpc": "2.0",
            "method": method,
        }

        if params:
            payload["params"] = params

        try:
            data = json.dumps(payload).encode("utf-8")
            req = Request(
                self.server_url,
                data=data,
                headers={"Content-Type": "application/json"},
                method="POST",
            )
            urlopen(req, timeout=self.timeout)
        except Exception as e:
            print(f"⚠️ 发送通知失败: {str(e)}")

    def list_tools(self) -> List[Dict[str, Any]]:
        """
        列出可用的 MCP 工具

        Returns:
            工具列表
        """
        if self._tools_cache is not None:
            return self._tools_cache

        try:
            result = self._send_request("tools/list")
            tools = result.get("tools", [])
            self._tools_cache = tools
            return tools

        except Exception as e:
            print(f"❌ 获取工具列表失败: {str(e)}")
            return []

    def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """
        调用 MCP 工具

        Args:
            tool_name: 工具名称
            arguments: 工具参数

        Returns:
            工具执行结果
        """
        try:
            result = self._send_request(
                "tools/call",
                {
                    "name": tool_name,
                    "arguments": arguments
                }
            )
            return result

        except Exception as e:
            return {
                "error": str(e),
                "content": []
            }


def extract_text_from_tool_result(result: Dict[str, Any]) -> str:
    """
    从 MCP ToolResult 中提取纯文本内容

    Args:
        result: 工具执行结果

    Returns:
        提取的文本内容
    """
    if "error" in result:
        return f"Error: {result['error']}"

    content_list = result.get("content", [])

    if not content_list:
        return ""

    # 处理不同类型的 content
    texts = []
    for content in content_list:
        if isinstance(content, str):
            texts.append(content)
        elif isinstance(content, dict):
            if content.get("type") == "text":
                texts.append(content.get("text", ""))
            elif "text" in content:
                texts.append(content["text"])

    return "\n".join(texts)


class ZReadRepoProvider:
    """
    ZRead 仓库内容提供者
    封装 ZRead MCP 工具调用
    """

    def __init__(self, repo_full_name: str, mcp_client: ZReadMCPClient):
        """
        初始化仓库提供者

        Args:
            repo_full_name: 仓库全名 (e.g., "owner/repo")
            mcp_client: MCP 客户端实例
        """
        self.repo_full_name = repo_full_name
        self.client = mcp_client
        self._tools_schema = None

    def _get_tool_schema(self) -> Dict[str, Any]:
        """获取工具参数 schema（用于自适应参数名）"""
        if self._tools_schema is None:
            tools = self.client.list_tools()
            self._tools_schema = {
                tool["name"]: tool.get("inputSchema", {})
                for tool in tools
            }
        return self._tools_schema

    def _call_tool_adaptive(self, tool_name: str, **kwargs) -> Dict[str, Any]:
        """
        自适应调用工具（根据 schema 调整参数名）

        Args:
            tool_name: 工具名称
            **kwargs: 工具参数

        Returns:
            工具执行结果
        """
        schema = self._get_tool_schema()
        tool_schema = schema.get(tool_name, {})

        # 获取 schema 定义的参数名
        properties = tool_schema.get("properties", {})
        schema_params = set(properties.keys())

        # 如果参数名匹配，直接使用
        if set(kwargs.keys()).issubset(schema_params):
            return self.client.call_tool(tool_name, kwargs)

        # 否则尝试参数名映射
        mapped_args = {}
        for key, value in kwargs.items():
            # 查找匹配的参数名（忽略大小写和下划线）
            matched = None
            for schema_param in schema_params:
                if key.lower().replace("_", "") == schema_param.lower().replace("_", ""):
                    matched = schema_param
                    break

            if matched:
                mapped_args[matched] = value
            else:
                # 保持原参数名
                mapped_args[key] = value

        return self.client.call_tool(tool_name, mapped_args)

    def read_file(self, file_path: str) -> Dict[str, Any]:
        """
        读取仓库中的文件内容

        Args:
            file_path: 文件路径（相对于仓库根目录）

        Returns:
            包含文件内容和元数据的字典
        """
        try:
            result = self._call_tool_adaptive(
                "mcp__zread__read_file",
                repo_name=self.repo_full_name,
                file_path=file_path
            )

            content = extract_text_from_tool_result(result)

            return {
                "success": True,
                "file_path": file_path,
                "content": content,
                "source": "zread_mcp",
                "repo_full_name": self.repo_full_name,
                "total_lines": len(content.split("\n")) if content else 0,
            }

        except Exception as e:
            return {
                "success": False,
                "error": f"读取文件失败: {str(e)}",
                "content": ""
            }

    def get_repo_structure(self, dir_path: str = "/") -> Dict[str, Any]:
        """
        获取仓库目录结构

        Args:
            dir_path: 目录路径（默认为根目录）

        Returns:
            包含目录结构的字典
        """
        try:
            result = self._call_tool_adaptive(
                "mcp__zread__get_repo_structure",
                repo_name=self.repo_full_name,
                dir_path=dir_path
            )

            content = extract_text_from_tool_result(result)

            return {
                "success": True,
                "directory": dir_path,
                "structure": content,
                "source": "zread_mcp",
                "repo_full_name": self.repo_full_name
            }

        except Exception as e:
            return {
                "success": False,
                "error": f"获取目录结构失败: {str(e)}",
                "structure": {}
            }

    def search_doc(self, query: str, language: str = "zh") -> Dict[str, Any]:
        """
        搜索仓库文档、issue、commit 等

        Args:
            query: 搜索查询
            language: 语言 ("zh" 或 "en")

        Returns:
            搜索结果
        """
        try:
            result = self._call_tool_adaptive(
                "mcp__zread__search_doc",
                repo_name=self.repo_full_name,
                query=query,
                language=language
            )

            content = extract_text_from_tool_result(result)

            return {
                "success": True,
                "query": query,
                "results": content,
                "source": "zread_mcp"
            }

        except Exception as e:
            return {
                "success": False,
                "error": f"搜索失败: {str(e)}",
                "results": ""
            }


def create_zread_provider(
    repo_full_name: str,
    server_url: Optional[str] = None,
    api_key: Optional[str] = None,
    timeout: int = 30
) -> Optional[ZReadRepoProvider]:
    """
    创建 ZRead 仓库提供者（工厂函数）

    Args:
        repo_full_name: 仓库全名 (e.g., "owner/repo")
        server_url: MCP 服务器 URL（默认从环境变量读取）
        api_key: API Key（默认从环境变量读取）
        timeout: 请求超时时间

    Returns:
        ZReadRepoProvider 实例，失败返回 None
    """
    if server_url is None:
        server_url = os.getenv("ZREAD_MCP_SERVER_URL", "http://localhost:3000/mcp")

    if api_key is None:
        api_key = os.getenv("ZREAD_MCP_API_KEY")

    try:
        client = ZReadMCPClient(server_url, api_key=api_key, timeout=timeout)
        if not client.initialize():
            return None

        return ZReadRepoProvider(repo_full_name, client)

    except Exception as e:
        print(f"❌ 创建 ZRead 提供者失败: {str(e)}")
        return None
