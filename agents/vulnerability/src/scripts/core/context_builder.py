"""
Context Builder - 上下文最小化 MCP工具
只给定义+调用+config，禁止模型"猜上下文"
"""

import os
import re
from typing import List, Dict, Any, Optional, Set
from pathlib import Path
from dataclasses import dataclass

from langchain_core.tools import tool


@dataclass
class SymbolContext:
    """符号上下文信息"""
    definition: str
    callers: List[str]
    callees: List[str]
    related_config: List[str]
    imports: List[str]
    exports: List[str]
    file_path: str
    line_number: int


class ContextBuilder:
    """上下文构建器 - 最小化上下文范围"""

    def __init__(self, base_dir: str = None):
        """初始化上下文构建器"""
        self.base_dir = Path(base_dir) if base_dir else Path.cwd()
        self.file_cache: Dict[str, str] = {}

    def _read_file_cached(self, file_path: str) -> str:
        """缓存读取文件内容"""
        if file_path not in self.file_cache:
            try:
                with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                    self.file_cache[file_path] = f.read()
            except Exception as e:
                return ""
        return self.file_cache[file_path]

    def _extract_symbols_from_file(self, file_path: str, target_symbol: str) -> List[Dict[str, Any]]:
        """从文件中提取所有符号定义"""
        content = self._read_file_cached(file_path)
        if not content:
            return []

        symbols = []
        lines = content.split('\n')

        function_pattern = re.compile(
            r'^\s*def\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([^)]*)\)\s*:.*$',
            re.MULTILINE
        )

        class_pattern = re.compile(
            r'^\s*class\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:\(([^)]*)\))?\s*:.*$',
            re.MULTILINE
        )

        method_pattern = re.compile(
            r'^\s*(?:async\s+)?def\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([^)]*)\)\s*:.*$',
            re.MULTILINE
        )

        patterns = [
            ('function', function_pattern),
            ('class', class_pattern),
            ('method', method_pattern)
        ]

        for i, line in enumerate(lines):
            line_num = i + 1
            line_stripped = line.strip()

            for symbol_type, pattern in patterns:
                match = pattern.match(line_stripped)
                if match and match.group(1).lower() == target_symbol.lower():
                    symbols.append({
                        'type': symbol_type,
                        'name': match.group(1),
                        'signature': line_stripped,
                        'line_number': line_num,
                        'full_line': line
                    })
                    break

        return symbols

    def _find_callers(self, target_symbol: str, file_path: str) -> List[str]:
        """查找符号的调用者"""
        content = self._read_file_cached(file_path)
        if not content:
            return []

        callers = []
        lines = content.split('\n')
        target_pattern = re.compile(r'\b' + re.escape(target_symbol) + r'\s*\(')

        for i, line in enumerate(lines):
            if target_pattern.search(line):
                context_start = max(0, i - 3)
                context_end = min(len(lines), i + 4)
                context = '\n'.join(lines[context_start:context_end])
                callers.append(f"{file_path}:{i+1} - {context.strip()}")
                break

        return callers

    def _find_callees(self, target_symbol: str, file_path: str) -> List[str]:
        """查找符号调用的其他函数"""
        content = self._read_file_cached(file_path)
        if not content:
            return []

        symbols = self._extract_symbols_from_file(file_path, target_symbol)
        if not symbols:
            return []

        symbol_info = symbols[0]
        definition_start = symbol_info['line_number'] - 1

        lines = content.split('\n')
        if definition_start >= len(lines):
            return []

        callees = []
        in_function = False
        brace_level = 0

        for i in range(definition_start, len(lines)):
            line = lines[i]

            if '{' in line:
                brace_level += line.count('{')
                in_function = True
            if '}' in line:
                brace_level -= line.count('}')
                if brace_level <= 0:
                    break

            if not in_function:
                continue

            call_patterns = [
                r'\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(',
                r'\b([a-zA-Z_][a-zA-Z0-9_]*)\s+\.',
                r'\bimport\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*',
                r'\bfrom\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+'
            ]

            for pattern in call_patterns:
                matches = re.findall(pattern, line)
                for match in matches:
                    if match != target_symbol:
                        callees.append(f"{file_path}:{i+1} - calls {match}")

        return callees

    def _find_related_config(self, target_symbol: str, file_path: str) -> List[str]:
        """查找相关的配置项"""
        content = self._read_file_cached(file_path)
        if not content:
            return []

        config_patterns = [
            r'\b(CONFIG|Settings|config|settings)\s*[=.]?\s*',
            r'\b(os\.environ|os\.get)\s*\(\s*[\'"]',
            r'\b(app\.|settings\.)',
            r'\b\.\s*config\.',
            r'@.*config'
        ]

        related_config = []
        lines = content.split('\n')

        for i, line in enumerate(lines):
            for pattern in config_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    related_config.append(f"{file_path}:{i+1} - {line.strip()}")
                    break

        return related_config

    def _get_file_imports_exports(self, file_path: str) -> tuple[List[str], List[str]]:
        """获取文件的导入和导出"""
        content = self._read_file_cached(file_path)
        if not content:
            return [], []

        imports = []
        exports = []

        lines = content.split('\n')
        for line in lines:
            line_stripped = line.strip()

            if line_stripped.startswith('import '):
                imports.append(line_stripped)
            elif line_stripped.startswith('from '):
                imports.append(line_stripped)
            elif '__all__' in line_stripped:
                exports.append(line_stripped)
            elif line_stripped.startswith('def ') and line_stripped.endswith('_export'):
                exports.append(line_stripped)

        return imports, exports


@tool
def get_symbol_context(file_path: str, symbol_name: str) -> Dict[str, Any]:
    """获取符号的上下文信息（定义、调用者、被调用者、配置）"""
    try:
        builder = ContextBuilder()

        context = SymbolContext(
            definition="",
            callers=[],
            callees=[],
            related_config=[],
            imports=[],
            exports=[],
            file_path=file_path,
            line_number=0
        )

        symbols = builder._extract_symbols_from_file(file_path, symbol_name)
        if symbols:
            symbol_info = symbols[0]
            context.definition = symbol_info['signature']
            context.line_number = symbol_info['line_number']

        context.callers = builder._find_callers(symbol_name, file_path)
        context.callees = builder._find_callees(symbol_name, file_path)
        context.related_config = builder._find_related_config(symbol_name, file_path)
        context.imports, context.exports = builder._get_file_imports_exports(file_path)

        return {
            "success": True,
            "context": {
                "definition": context.definition,
                "callers": context.callers,
                "callees": context.callees,
                "related_config": context.related_config,
                "imports": context.imports,
                "exports": context.exports,
                "file_path": context.file_path,
                "line_number": context.line_number
            }
        }

    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "context": {}
        }


@tool
def get_file_analysis(file_path: str) -> Dict[str, Any]:
    """获取文件分析信息"""
    try:
        builder = ContextBuilder()
        content = builder._read_file_cached(file_path)

        if not content:
            return {
                "success": False,
                "error": "无法读取文件或文件为空",
                "analysis": {}
            }

        lines = content.split('\n')

        analysis = {
            "total_lines": len(lines),
            "functions": len([line for line in lines if re.match(r'^\s*(def\s+|async\s+def\s+)', line)]),
            "classes": len([line for line in lines if re.match(r'^\s*class\s+', line)]),
            "conditionals": len([line for line in lines if re.search(r'\bif\s+', line)]),
            "loops": len([line for line in lines if re.search(r'\b(for\s+|while\s+)', line)]),
            "imports": len([line for line in lines if line.strip().startswith('import ')]),
            "exports": len([line for line in lines if line.strip().startswith('__all__') or line.strip().endswith('_export')]),
            "language": builder.detect_language(file_path) if hasattr(builder, 'detect_language') else 'unknown'
        }

        return {
            "success": True,
            "analysis": analysis
        }

    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "analysis": {}
        }


@tool
def search_symbol_references(symbol_name: str, max_results: int = 10) -> Dict[str, Any]:
    """搜索符号的所有引用"""
    try:
        builder = ContextBuilder()
        references = []

        for py_file in Path(builder.base_dir).rglob('**/*.py'):
            try:
                content = builder._read_file_cached(str(py_file))
                if not content:
                    continue

                lines = content.split('\n')
                for i, line in enumerate(lines):
                    if re.search(r'\b' + re.escape(symbol_name) + r'\b', line):
                        context_start = max(0, i - 2)
                        context_end = min(len(lines), i + 3)
                        context = '\n'.join(lines[context_start:context_end])

                        references.append({
                            'file_path': str(py_file),
                            'line_number': i + 1,
                            'context': context.strip(),
                            'is_definition': any(keyword in context for keyword in ['def ', 'class ']) and symbol_name in context
                        })

                        if len(references) >= max_results:
                            break

                if len(references) >= max_results:
                    break

            except Exception:
                continue

        return {
            "success": True,
            "symbol": symbol_name,
            "references": references,
            "total_found": len(references)
        }

    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "symbol": symbol_name,
            "references": [],
            "total_found": 0
        }