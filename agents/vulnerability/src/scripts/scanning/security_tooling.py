"""
Security Tooling - 工具增强证据收集
基于符号和静态分析收集安全审计所需的关键证据
"""

import logging
import os
import re
from pathlib import Path
from typing import Any, Dict, List, Set, Optional

from ..todolist.todolist_generator import create_code_tools_for_pr
from .parallel_semgrep_scanner import run_parallel_semgrep_tasks

logger = logging.getLogger(__name__)


class SecurityTooling:
    """安全证据收集工具类"""

    def __init__(self, pr_dir: str, feature_risk_plan: Dict[str, Any], codebase_path: Optional[str] = None):
        """初始化安全工具集"""
        self.pr_dir = pr_dir
        self.feature_risk_plan = feature_risk_plan

        tools_bundle = create_code_tools_for_pr(pr_dir, feature_risk_plan, codebase_path)
        self.code_tools = tools_bundle["code_tools"]

        self._scan_config = self._init_scan_config()

    def _init_scan_config(self) -> Dict[str, Any]:
        """初始化扫描配置"""
        all_templates = set()
        for feature in self.feature_risk_plan.get("features", []):
            for task in feature.get("scan_tasks", []):
                all_templates.add(task.get("template", ""))

        complex_templates = {
            "PY_UPSTREAM_CALLGRAPH",
            "PY_ARGUMENT_SOURCES_AT_CALLSITE",
        }

        has_complex = bool(all_templates & complex_templates)

        return {
            "max_workers": min(8, os.cpu_count() or 4),
            "max_findings": 300,
            "timeout_seconds": 180 if has_complex else 60,
            "has_complex_templates": has_complex,
        }

    def run_parallel_template_scan(
        self,
        source_code_path: str,
        output_dir: Optional[str] = None
    ) -> Dict[str, Any]:
        """运行并行模板扫描"""
        logger.info(f"[Security Tooling] 启动并行模板扫描")
        logger.info(f"  源代码路径: {source_code_path}")
        logger.info(f"  并行线程: {self._scan_config['max_workers']}")
        logger.info(f"  超时设置: {self._scan_config['timeout_seconds']}s")

        if output_dir is None:
            output_dir = str(Path(self.pr_dir) / "out")

        try:
            result = run_parallel_semgrep_tasks(
                pr_dir=source_code_path,
                feature_risk_plan=self.feature_risk_plan,
                max_workers=self._scan_config["max_workers"],
                max_findings=self._scan_config["max_findings"],
                timeout_seconds=self._scan_config["timeout_seconds"],
                output_dir=output_dir
            )

            if result.get("success"):
                logger.info(f"[Security Tooling] 扫描完成")
                logger.info(f"  总任务: {result['summary']['total_tasks']}")
                logger.info(f"  成功: {result['summary']['successful_tasks']}")
                logger.info(f"  失败: {result['summary']['failed_tasks']}")
                logger.info(f"  发现: {result['summary']['total_findings']}")
            else:
                logger.warning(f"[Security Tooling] 扫描部分失败")

            return result

        except Exception as e:
            logger.error(f"[Security Tooling] 扫描失败: {str(e)}")
            return {
                "success": False,
                "error": str(e),
                "summary": {},
                "evidence": []
            }

    def _is_symbol_in_modified_lines(self, file_path: str, symbol_name: str, modified_lines: List[int]) -> bool:
        """判断符号是否在修改的行范围内

        Args:
            file_path: 文件路径
            symbol_name: 符号名称
            modified_lines: 修改的行号列表

        Returns:
            bool: 是否在修改范围内
        """
        if not modified_lines:
            return True

        # 读取文件内容
        rf = self.code_tools.read_file(file_path)
        if not rf.get("success"):
            logger.warning(f"[Security Tooling] 无法读取文件: {file_path}")
            return False

        content = rf.get("content", "")
        lines = content.split('\n')

        # 查找符号定义位置
        symbol_pattern = rf'(def |class |function |var |let |const |public |private |protected )\s*{re.escape(symbol_name)}\b'

        for i, line in enumerate(lines, 1):
            if re.search(symbol_pattern, line):
                # 检查是否在修改范围内（允许前后10行容差）
                for modified_line in modified_lines:
                    if abs(i - modified_line) <= 10:
                        return True
                break

        return False

    def discover_entrypoints(self, file_path: str, symbol_name: str = "", modified_lines: List[int] = None) -> List[Dict[str, Any]]:
        """发现外部入口点

        Args:
            file_path: 文件路径
            symbol_name: 符号名称
            modified_lines: 修改的行号列表

        Returns:
            List[Dict]: 发现的入口点列表
        """
        logger.debug(f"[Security Tooling] 发现入口点: {file_path}::{symbol_name}")

        entrypoints = []

        # 读取文件内容
        rf = self.code_tools.read_file(file_path)
        if not rf.get("success"):
            logger.warning(f"[Security Tooling] 无法读取文件: {file_path}")
            return entrypoints

        content = rf.get("content", "")
        lines = content.split('\n')

        # 查找Web框架入口点
        for i, line in enumerate(lines, 1):
            for pattern in self.web_framework_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    # 检查是否与目标符号相关
                    if symbol_name and symbol_name in line:
                        entrypoints.append({
                            "type": "web_endpoint",
                            "file": file_path,
                            "line": i,
                            "snippet": line.strip(),
                            "method": self._extract_http_method(line),
                            "path": self._extract_route_path(line),
                            "framework": self._detect_framework(content)
                        })
                    elif not symbol_name:
                        # 如果没有指定符号，记录所有入口点
                        entrypoints.append({
                            "type": "web_endpoint",
                            "file": file_path,
                            "line": i,
                            "snippet": line.strip(),
                            "method": self._extract_http_method(line),
                            "path": self._extract_route_path(line),
                            "framework": self._detect_framework(content)
                        })

        # 查找RPC/消息队列入口点
        rpc_patterns = [
            r'@rpc\.',
            r'@message_handler\.',
            r'@kafka_listener\.',
            r'@rabbitmq_listener\.',
            r'@grpc\.',
        ]

        for i, line in enumerate(lines, 1):
            for pattern in rpc_patterns:
                if re.search(pattern, line):
                    if symbol_name and symbol_name in line:
                        entrypoints.append({
                            "type": "rpc_endpoint",
                            "file": file_path,
                            "line": i,
                            "snippet": line.strip(),
                            "protocol": self._extract_protocol_type(line)
                        })

        return entrypoints

    def trace_call_chain(self, file_path: str, symbol_name: str, modified_lines: List[int] = None) -> Dict[str, Any]:
        """追踪从入口点到危险符号的调用链

        Args:
            file_path: 文件路径
            symbol_name: 符号名称
            modified_lines: 修改的行号列表

        Returns:
            Dict: 调用链信息
        """
        logger.debug(f"[Security Tooling] 追踪调用链: {file_path}::{symbol_name}")

        call_chain = {
            "has_chain": False,
            "entry_points": [],
            "intermediate_calls": [],
            "danger_point": None,
            "confidence": "low"
        }

        # 1. 发现入口点
        entrypoints = self.discover_entrypoints(file_path, symbol_name, modified_lines)
        call_chain["entry_points"] = entrypoints

        if not entrypoints:
            logger.debug(f"[Security Tooling] 未发现入口点: {symbol_name}")
            return call_chain

        # 2. 追踪调用链
        rf = self.code_tools.read_file(file_path)
        if not rf.get("success"):
            return call_chain

        content = rf.get("content", "")

        # 查找危险点
        danger_patterns = (
            self.db_operation_patterns +
            self.command_patterns +
            self.file_operation_patterns +
            self.deserialization_patterns
        )

        danger_points = []
        for i, line in enumerate(content.split('\n'), 1):
            for pattern in danger_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    if symbol_name in line or self._is_related_to_symbol(line, symbol_name):
                        danger_points.append({
                            "line": i,
                            "snippet": line.strip(),
                            "type": self._classify_danger_type(pattern, line),
                            "context_lines": self._get_context_lines(content, i, 3)
                        })

        if danger_points:
            call_chain["danger_point"] = danger_points[0]  # 取第一个危险点
            call_chain["has_chain"] = True
            call_chain["confidence"] = "medium" if entrypoints else "low"

            # 构建中间调用链
            call_chain["intermediate_calls"] = self._build_intermediate_calls(
                content, entrypoints, danger_points[0]
            )

        return call_chain

    def find_framework_routes(self, file_path: str) -> List[Dict[str, Any]]:
        """发现框架自动暴露的路由

        Args:
            file_path: 文件路径

        Returns:
            List[Dict]: 框架路由信息
        """
        logger.debug(f"[Security Tooling] 发现框架路由: {file_path}")

        routes = []

        rf = self.code_tools.read_file(file_path)
        if not rf.get("success"):
            return routes

        content = rf.get("content", "")

        # 检测不同框架的路由模式
        framework_checks = [
            ("flask", r'@app\.route\(|@bp\.route\(|Blueprint\('),
            ("django", r'path\(|url\(|views\.'),
            ("fastapi", r'@app\.|@router\.|APIRouter\('),
            ("express", r'app\.(get|post|put|delete|patch)|router\.'),
            ("spring", r'@GetMapping|@PostMapping|@RequestMapping|@RestController'),
        ]

        detected_frameworks = []
        for framework, pattern in framework_checks:
            if re.search(pattern, content, re.IGNORECASE):
                detected_frameworks.append(framework)

        # 提取具体路由
        for framework in detected_frameworks:
            if framework == "flask":
                routes.extend(self._extract_flask_routes(content))
            elif framework == "django":
                routes.extend(self._extract_django_urls(content))
            elif framework == "fastapi":
                routes.extend(self._extract_fastapi_routes(content))
            elif framework == "express":
                routes.extend(self._express_routes(content))
            elif framework == "spring":
                routes.extend(self._extract_spring_routes(content))

        return routes

    def collect_context_evidence(self, file_path: str, symbol_name: str) -> List[Dict[str, Any]]:
        """收集上下文证据（相邻模块的关联漏洞）

        Args:
            file_path: 文件路径
            symbol_name: 符号名称

        Returns:
            List[Dict]: 上下文证据列表
        """
        logger.debug(f"[Security Tooling] 收集上下文证据: {file_path}::{symbol_name}")

        context_evidence = []

        # 读取目标文件
        rf = self.code_tools.read_file(file_path)
        if not rf.get("success"):
            return context_evidence

        content = rf.get("content", "")

        # 查找同一文件中的相关符号
        related_symbols = self._find_related_symbols(content, symbol_name)

        for symbol in related_symbols:
            symbol_info = {
                "type": "related_symbol",
                "symbol": symbol,
                "file": file_path,
                "usage": self._find_symbol_usage(content, symbol)
            }
            context_evidence.append(symbol_info)

        # 查找同目录下的相关文件
        related_files = self._find_related_files(file_path)
        for related_file in related_files:
            file_info = {
                "type": "related_file",
                "file": related_file,
                "relation": self._classify_file_relation(file_path, related_file)
            }
            context_evidence.append(file_info)

        return context_evidence

    def system_collect_evidence(self, file_path: str, symbol_name: str = "", modified_lines: List[int] = None) -> Dict[str, Any]:
        """系统化收集四类关键证据

        Args:
            file_path: 文件路径
            symbol_name: 符号名称
            modified_lines: 修改的行号列表

        Returns:
            Dict: 完整的证据收集结果
        """
        logger.info(f"[Security Tooling] 系统化收集证据: {file_path}::{symbol_name}")

        evidence_result = {
            "file_path": file_path,
            "symbol_name": symbol_name,
            "entrypoint_evidence": [],
            "call_chain_evidence": {},
            "framework_evidence": [],
            "context_evidence": [],
            "summary": {
                "has_entrypoint": False,
                "has_call_chain": False,
                "has_framework_routes": False,
                "related_context": False,
                "confidence_score": 0
            }
        }

        try:
            # 1. 收集入口点证据
            entrypoint_evidence = self.discover_entrypoints(file_path, symbol_name, modified_lines)
            evidence_result["entrypoint_evidence"] = entrypoint_evidence
            evidence_result["summary"]["has_entrypoint"] = len(entrypoint_evidence) > 0

            # 2. 收集调用链证据
            call_chain_evidence = self.trace_call_chain(file_path, symbol_name, modified_lines)
            evidence_result["call_chain_evidence"] = call_chain_evidence
            evidence_result["summary"]["has_call_chain"] = call_chain_evidence.get("has_chain", False)

            # 3. 收集框架路由证据
            framework_evidence = self.find_framework_routes(file_path)
            evidence_result["framework_evidence"] = framework_evidence
            evidence_result["summary"]["has_framework_routes"] = len(framework_evidence) > 0

            # 4. 收集上下文证据
            context_evidence = self.collect_context_evidence(file_path, symbol_name)
            evidence_result["context_evidence"] = context_evidence
            evidence_result["summary"]["related_context"] = len(context_evidence) > 0

            # 计算置信度分数
            score = 0
            if evidence_result["summary"]["has_entrypoint"]:
                score += 30
            if evidence_result["summary"]["has_call_chain"]:
                score += 40
            if evidence_result["summary"]["has_framework_routes"]:
                score += 20
            if evidence_result["summary"]["related_context"]:
                score += 10

            evidence_result["summary"]["confidence_score"] = score

            logger.info(f"[Security Tooling] 证据收集完成 - 置信度: {score}/100")

        except Exception as e:
            logger.error(f"[Security Tooling] 证据收集失败: {str(e)}")
            evidence_result["error"] = str(e)

        return evidence_result

    # ============ 辅助方法 ============

    def _extract_http_method(self, line: str) -> str:
        """提取HTTP方法"""
        methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"]
        for method in methods:
            if method.lower() in line.lower():
                return method
        return "UNKNOWN"

    def _extract_route_path(self, line: str) -> str:
        """提取路由路径"""
        # 简单的路由路径提取
        patterns = [
            r'["\']([^"\']+)["\']',
            r'path\s*=\s*["\']([^"\']+)["\']',
        ]

        for pattern in patterns:
            match = re.search(pattern, line)
            if match:
                return match.group(1)

        return "UNKNOWN_PATH"

    def _detect_framework(self, content: str) -> str:
        """检测Web框架类型"""
        if "from flask" in content or "import flask" in content:
            return "flask"
        elif "from django" in content or "import django" in content:
            return "django"
        elif "from fastapi" in content or "import fastapi" in content:
            return "fastapi"
        elif "require('express')" in content or "import express" in content:
            return "express"
        elif "import org.springframework" in content or "@SpringBootApplication" in content:
            return "spring"
        else:
            return "unknown"

    def _extract_protocol_type(self, line: str) -> str:
        """提取协议类型"""
        if "kafka" in line.lower():
            return "kafka"
        elif "rabbitmq" in line.lower():
            return "rabbitmq"
        elif "grpc" in line.lower():
            return "grpc"
        else:
            return "rpc"

    def _classify_danger_type(self, pattern: str, line: str) -> str:
        """分类危险点类型"""
        if any(p in pattern for p in self.db_operation_patterns):
            return "sql_injection"
        elif any(p in pattern for p in self.command_patterns):
            return "command_injection"
        elif any(p in pattern for p in self.file_operation_patterns):
            return "path_traversal"
        elif any(p in pattern for p in self.deserialization_patterns):
            return "deserialization"
        else:
            return "unknown"

    def _get_context_lines(self, content: str, line_num: int, context_size: int = 3) -> List[str]:
        """获取上下文行"""
        lines = content.split('\n')
        start = max(0, line_num - context_size - 1)
        end = min(len(lines), line_num + context_size)
        return lines[start:end]

    def _is_related_to_symbol(self, line: str, symbol_name: str) -> bool:
        """判断代码行是否与符号相关"""
        if not symbol_name:
            return True

        # 简单的相关性判断
        return symbol_name in line or any(
            word in line.lower()
            for word in [symbol_name.lower(), symbol_name.lower() + "(", "self." + symbol_name.lower()]
        )

    def _build_intermediate_calls(self, content: str, entrypoints: List[Dict], danger_point: Dict) -> List[Dict]:
        """构建中间调用链"""
        # 简化实现：在入口点和危险点之间查找可能的调用关系
        intermediate_calls = []

        # 这里可以实现更复杂的调用图分析
        # 目前返回空列表，表示直接调用

        return intermediate_calls

    def _extract_flask_routes(self, content: str) -> List[Dict]:
        """提取Flask路由"""
        routes = []
        pattern = r'@.*?\.route\(["\']([^"\']+)["\'].*?\)\s*def\s+(\w+)\s*\('

        for match in re.finditer(pattern, content, re.MULTILINE | re.DOTALL):
            routes.append({
                "framework": "flask",
                "path": match.group(1),
                "function": match.group(2),
                "type": "web_route"
            })

        return routes

    def _extract_django_urls(self, content: str) -> List[Dict]:
        """提取Django URL"""
        routes = []
        pattern = r'path\(["\']([^"\']+)["\'].*?,.*?(\w+)\.as_view\(\)'

        for match in re.finditer(pattern, content):
            routes.append({
                "framework": "django",
                "path": match.group(1),
                "view": match.group(2),
                "type": "web_route"
            })

        return routes

    def _extract_fastapi_routes(self, content: str) -> List[Dict]:
        """提取FastAPI路由"""
        routes = []
        pattern = r'@(app|router)\.(get|post|put|delete|patch)\(["\']([^"\']+)["\']'

        for match in re.finditer(pattern, content):
            routes.append({
                "framework": "fastapi",
                "path": match.group(3),
                "method": match.group(2).upper(),
                "type": "web_route"
            })

        return routes

    def _express_routes(self, content: str) -> List[Dict]:
        """提取Express路由"""
        routes = []
        pattern = r'(app|router)\.(get|post|put|delete|patch)\(["\']([^"\']+)["\']'

        for match in re.finditer(pattern, content):
            routes.append({
                "framework": "express",
                "path": match.group(3),
                "method": match.group(2).upper(),
                "type": "web_route"
            })

        return routes

    def _extract_spring_routes(self, content: str) -> List[Dict]:
        """提取Spring路由"""
        routes = []
        pattern = r'@(Get|Post|Put|Delete|Patch)Mapping\(["\']([^"\']+)["\']'

        for match in re.finditer(pattern, content):
            routes.append({
                "framework": "spring",
                "path": match.group(2),
                "method": match.group(1).replace("Mapping", ""),
                "type": "web_route"
            })

        return routes

    def _find_related_symbols(self, content: str, symbol_name: str) -> List[str]:
        """查找相关符号"""
        related_symbols = []

        # 查找相似的函数名
        pattern = rf'def\s+(\w*{re.escape(symbol_name)}\w*)\s*\('
        for match in re.finditer(pattern, content):
            func_name = match.group(1)
            if func_name != symbol_name:
                related_symbols.append(func_name)

        return related_symbols

    def _find_symbol_usage(self, content: str, symbol_name: str) -> List[str]:
        """查找符号使用位置"""
        usages = []
        pattern = rf'\b{re.escape(symbol_name)}\b'

        for i, line in enumerate(content.split('\n'), 1):
            if re.search(pattern, line) and f'def {symbol_name}' not in line:
                usages.append(f"line_{i}: {line.strip()}")

        return usages[:5]  # 最多返回5个使用位置

    def _find_related_files(self, file_path: str) -> List[str]:
        """查找相关文件"""
        # 这里可以实现更智能的文件关联分析
        # 目前返回空列表
        return []

    def _classify_file_relation(self, file_path: str, related_file: str) -> str:
        """分类文件关系"""
        # 简化实现
        return "unknown"


# 工厂函数
def create_security_tooling(
    pr_dir: str,
    feature_risk_plan: Dict[str, Any],
    codebase_path: Optional[str] = None
) -> SecurityTooling:
    """创建安全工具实例

    Args:
        pr_dir: PR目录路径
        feature_risk_plan: 功能风险计划
        codebase_path: 克隆的源代码路径（优先使用）

    Returns:
        SecurityTooling: 安全工具实例
    """
    return SecurityTooling(pr_dir, feature_risk_plan, codebase_path)