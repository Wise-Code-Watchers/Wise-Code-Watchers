"""基于模板的 Semgrep 扫描器

用于执行 feature_risk_plan 中由 LLM 规划出的 scan_tasks。

策略：
- 从 src/semgrep_rules/templates 读取模板 YAML
- 进行简单占位符替换（{{SYMBOL}}/{{FIELD}}/{{MODE}}）
- 合并成临时 semgrep config 后执行 `semgrep --config <tmp> --json` 扫描
- 输出结构化结果，保存到PR的out目录
- 按功能和任务分类结果，供 evidence_store/final_report 使用
"""

from __future__ import annotations

import json
import os
import subprocess
import tempfile
from collections import defaultdict
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False


TEMPLATE_DIR = Path(__file__).resolve().parent.parent.parent / "semgrep_rules" / "templates"


_TEMPLATE_FILE_MAP = {
    # Python 模板
    "PY_CALLERS_OF_FUNCTION": "py_callers_of_function.template.yaml",
    "PY_UPSTREAM_CALLGRAPH": "py_upstream_callgraph.template.yaml",
    "PY_RETURN_VALUE_USAGE": "py_return_value_usage.template.yaml",
    "PY_EXCEPTION_HANDLING_AROUND_CALL": "py_exception_handling_around_call.template.yaml",
    "PY_REFERENCES_OF_SYMBOL": "py_references_of_symbol.template.yaml",
    "PY_FIELD_READ_WRITE_SITES": "py_field_read_write_sites.template.yaml",
    "PY_ARGUMENT_SOURCES_AT_CALLSITE": "py_argument_sources_at_callsite.template.yaml",
    # Java 模板
    "JAVA_CALLERS_OF_METHOD": "java_callers_of_method.template.yaml",
    "JAVA_METHOD_OVERRIDE": "java_method_override.template.yaml",
    "JAVA_EXCEPTION_HANDLING": "java_exception_handling.template.yaml",
    "JAVA_FIELD_READ_WRITE": "java_field_read_write.template.yaml",
    "JAVA_ANNOTATION_USAGE": "java_annotation_usage.template.yaml",
    "JAVA_ARGUMENT_SOURCES": "java_argument_sources.template.yaml",
    # Go 模板
    "GO_CALLERS_OF_FUNCTION": "go_callers_of_function.template.yaml",
    "GO_DEFER_USAGE": "go_defer_usage.template.yaml",
    "GO_ERROR_HANDLING": "go_error_handling.template.yaml",
    "GO_GOROUTINE_SPAWN": "go_goroutine_spawn.template.yaml",
    "GO_INTERFACE_METHOD": "go_interface_method.template.yaml",
    "GO_FIELD_READ_WRITE": "go_field_read_write.template.yaml",
    # C 模板
    "C_CALLERS_OF_FUNCTION": "c_callers_of_function.template.yaml",
    "C_POINTER_OPERATIONS": "c_pointer_operations.template.yaml",
    "C_MEMORY_OPERATIONS": "c_memory_operations.template.yaml",
    "C_BUFFER_OPERATIONS": "c_buffer_operations.template.yaml",
    "C_NULL_CHECK": "c_null_check.template.yaml",
    "C_RETURN_VALUE": "c_return_value.template.yaml",
    # Ruby 模板
    "RB_CALLERS_OF_METHOD": "rb_callers_of_method.template.yaml",
    "RB_METHOD_MISSING": "rb_method_missing.template.yaml",
    "RB_EVAL_USAGE": "rb_eval_usage.template.yaml",
    "RB_BLOCK_USAGE": "rb_block_usage.template.yaml",
    "RB_EXCEPTION_HANDLING": "rb_exception_handling.template.yaml",
    "RB_ATTR_ACCESS": "rb_attr_access.template.yaml",
    # TypeScript 模板
    "TS_CALLERS_OF_FUNCTION": "ts_callers_of_function.template.yaml",
    "TS_PROMISE_USAGE": "ts_promise_usage.template.yaml",
    "TS_TYPE_ASSERTION": "ts_type_assertion.template.yaml",
    "TS_NULL_HANDLING": "ts_null_handling.template.yaml",
    "TS_DECORATOR_USAGE": "ts_decorator_usage.template.yaml",
    "TS_EXCEPTION_HANDLING": "ts_exception_handling.template.yaml",
    "TS_FIELD_READ_WRITE": "ts_field_read_write.template.yaml",
}


def _render_template(text: str, params: Dict[str, str]) -> str:
    out = text
    for k, v in params.items():
        out = out.replace("{{" + k + "}}", v)
    return out


def _safe_ident(s: str) -> str:
    # 防止注入到 YAML / semgrep pattern 中（这里仅允许常规 python 标识符和点号）
    s = (s or "").strip()
    if not s:
        return ""
    for ch in s:
        if not (ch.isalnum() or ch in {"_", "."}):
            return ""
    return s


def _ensure_templates_exist() -> None:
    if not TEMPLATE_DIR.exists():
        raise FileNotFoundError(f"Template directory not found: {TEMPLATE_DIR}")
    for _, fname in _TEMPLATE_FILE_MAP.items():
        fp = TEMPLATE_DIR / fname
        if not fp.exists():
            raise FileNotFoundError(f"Template file not found: {fp}")


def _build_config_from_tasks(tasks: List[Dict[str, Any]]) -> str:
    """将任务列表渲染为一个 semgrep config（YAML 文本）。"""
    _ensure_templates_exist()

    rendered_rules: List[str] = []
    for t in tasks:
        tpl = t.get("template")
        params = t.get("params", {}) or {}
        symbol = _safe_ident(params.get("symbol", ""))
        field = _safe_ident(params.get("field", ""))
        mode = (params.get("mode", "both") or "both").lower()

        template_file = _TEMPLATE_FILE_MAP.get(tpl)
        if not template_file:
            continue

        raw = (TEMPLATE_DIR / template_file).read_text(encoding="utf-8")

        # 基础替换
        rep = {
            "SYMBOL": symbol,
            "FIELD": field,
            "MODE": mode,
        }
        rendered = _render_template(raw, rep)
        rendered_rules.append(rendered)

    # 每个模板文件都以 rules: 开头，为避免多次 rules:，我们简单拼接后再做一次合并：
    # - 将每段中 'rules:' 去掉，只保留规则列表项
    merged_items: List[str] = []
    for block in rendered_rules:
        lines = block.splitlines()
        # 去掉开头的 rules:
        stripped = []
        for ln in lines:
            if ln.strip() == "rules:":
                continue
            stripped.append(ln)
        merged_items.append("\n".join(stripped).rstrip())

    return "rules:\n" + "\n\n".join(merged_items) + "\n"


def _flatten_feature_tasks(feature_risk_plan: Dict[str, Any]) -> List[Dict[str, Any]]:
    tasks: List[Dict[str, Any]] = []
    # 支持的语言列表
    supported_languages = {"python", "java", "go", "c", "cpp", "ruby", "typescript", "javascript"}
    
    for f in feature_risk_plan.get("features", []) or []:
        for t in f.get("scan_tasks", []) or []:
            # 获取语言，默认为python以保持向后兼容
            lang = (t.get("language") or "python").lower()
            # 检查是否为支持的语言
            if lang not in supported_languages:
                continue
            tasks.append(t)
    return tasks


def run_template_semgrep_tasks(
    pr_dir: str,
    feature_risk_plan: Dict[str, Any],
    max_findings: int = 300,
    timeout_seconds: int = 300,
) -> Dict[str, Any]:
    """执行模板扫描任务。

    Returns:
      {
        "success": bool,
        "results": semgrep_json,
        "summary": {...},
        "evidence": [ ... ],
        "raw_results_file": str,  # 原始结果文件路径
        "parsed_results_file": str  # 分类结果文件路径
      }
    """

    tasks = _flatten_feature_tasks(feature_risk_plan)
    if not tasks:
        return {
            "success": True,
            "results": {"results": []},
            "summary": {"tasks": 0, "findings": 0},
            "evidence": [],
        }

    cfg_text = _build_config_from_tasks(tasks)

    with tempfile.NamedTemporaryFile("w", suffix=".yaml", delete=False, encoding="utf-8") as tmp:
        tmp.write(cfg_text)
        tmp_path = tmp.name

    try:
        cmd = [
            "semgrep",
            f"--config={tmp_path}",
            "--json",
            "--quiet",
            f"--timeout={int(max(30, timeout_seconds // 3))}",
            pr_dir,
        ]

        try:
            r = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout_seconds)
        except subprocess.TimeoutExpired as e:
            # 超时时杀死子进程
            # 注意：subprocess.run 在超时后会尝试杀死进程组，但可能失败
            # 这里我们手动确保进程被终止

            killed = False
            if PSUTIL_AVAILABLE:
                try:
                    # 尝试找到并杀死所有相关的 semgrep 进程
                    for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                        try:
                            if proc.info['name'] and 'semgrep' in proc.info['name'].lower():
                                # 检查命令行参数是否包含我们的临时配置文件
                                cmdline = proc.info['cmdline'] or []
                                if any(tmp_path in arg for arg in cmdline):
                                    proc.kill()
                                    print(f"⚠️  已杀死超时的 semgrep 进程 (PID: {proc.info['pid']})")
                                    killed = True
                        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                            pass
                except Exception:
                    pass

            # 如果 psutil 不可用或失败，使用系统命令
            if not killed:
                try:
                    subprocess.run(['pkill', '-9', '-f', f'semgrep.*{tmp_path}'],
                                  capture_output=True, timeout=5)
                    print(f"⚠️  已尝试杀死超时的 semgrep 进程")
                except:
                    pass

            return {
                "success": False,
                "error": f"Template semgrep timeout after {timeout_seconds}s",
                "results": {"results": []},
                "summary": {"tasks": len(tasks), "findings": 0},
                "evidence": [],
            }

        if r.returncode not in [0, 1]:
            return {
                "success": False,
                "error": f"Template semgrep failed: {r.stderr}",
                "results": {"results": []},
                "summary": {"tasks": len(tasks), "findings": 0},
                "evidence": [],
            }

        data = json.loads(r.stdout) if r.stdout else {"results": []}
        results = data.get("results", []) or []

        # Semgrep CLI 不支持 --max-findings（不同版本差异），这里用脚本后处理限制输出数量
        if max_findings and isinstance(max_findings, int) and max_findings > 0:
            results = results[:max_findings]

        # 保存原始结果到PR的out目录
        out_dir = Path(pr_dir) / "out"
        out_dir.mkdir(parents=True, exist_ok=True)

        raw_results_file = out_dir / "semgrep_template_raw_results.json"
        with open(raw_results_file, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

        # 按功能分类结果
        grouped_result = _group_results_by_feature(results, feature_risk_plan, pr_dir)

        # 保存分类结果
        parsed_results_file = out_dir / "semgrep_template_parsed_results.json"
        with open(parsed_results_file, "w", encoding="utf-8") as f:
            json.dump(grouped_result, f, indent=2, ensure_ascii=False)

        evidence: List[Dict[str, Any]] = []
        for it in results:
            evidence.append(
                {
                    "engine": "semgrep_template",
                    "rule_id": it.get("check_id", ""),
                    "severity": (it.get("extra", {}).get("severity") or "INFO"),
                    "file_path": it.get("path", ""),
                    "line_start": it.get("start", {}).get("line", 0),
                    "line_end": it.get("end", {}).get("line", 0),
                    "message": it.get("extra", {}).get("message") or it.get("message", ""),
                    "snippet": it.get("extra", {}).get("lines", ""),
                    "metavars": it.get("extra", {}).get("metavars", {}),
                }
            )

        return {
            "success": True,
            "results": data,
            "summary": {
                "tasks": len(tasks),
                "findings": len(results),
                "features": grouped_result.get("scan_metadata", {}).get("total_features", 0),
                "features_with_results": grouped_result.get("scan_metadata", {}).get("features_with_results", 0)
            },
            "evidence": evidence,
            "raw_results_file": str(raw_results_file),
            "parsed_results_file": str(parsed_results_file),
            "grouped_results": grouped_result,
        }
    finally:
        try:
            os.remove(tmp_path)
        except Exception:
            pass


def _get_source_line(file_path: str, line_number: int) -> str:
    """从源文件读取指定行的代码"""
    try:
        with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
            lines = f.readlines()
            if 1 <= line_number <= len(lines):
                return lines[line_number - 1].strip()
    except Exception:
        pass
    return ""


def _format_semgrep_results(results: List[Dict], pr_dir: str) -> List[Dict]:
    """格式化Semgrep结果"""
    formatted = []
    pr_dir_str = str(pr_dir)

    for r in results:
        file_path = r.get('path', '')
        line = r.get('start', {}).get('line', 0)
        col = r.get('start', {}).get('col', 0)

        # 从源文件读取代码行
        code = _get_source_line(file_path, line)

        # 简化路径显示
        if file_path.startswith(pr_dir_str):
            short_path = file_path[len(pr_dir_str):].lstrip('/')
        else:
            short_path = file_path

        formatted.append({
            'file': short_path,
            'line': line,
            'col': col,
            'code': code,
            'check_id': r.get('check_id', 'unknown'),
            'message': r.get('extra', {}).get('message', '')
        })

    return formatted


def _group_results_by_feature(results: List[Dict], feature_risk_plan: Dict, pr_dir: str) -> Dict:
    """按照feature_risk_plan的功能分类结果"""
    # 格式化结果
    formatted_results = _format_semgrep_results(results, pr_dir)

    # 按check_id分组结果
    results_by_check = defaultdict(list)
    for result in formatted_results:
        check_id = result['check_id']
        results_by_check[check_id].append({
            'file': result['file'],
            'line': result['line'],
            'col': result['col'],
            'code': result['code']
        })

    # 构建feature结构
    features_output = []
    total_findings = 0
    features_with_results = 0

    for feature in feature_risk_plan.get("features", []) or []:
        feature_id = feature.get('feature_id', 'unknown')
        feature_name = feature.get('feature_name', '')
        risk_level = feature.get('risk_level', 'unknown')
        scan_tasks = feature.get('scan_tasks', [])

        tasks_output = []
        tasks_with_results = 0
        feature_findings = 0

        for idx, task in enumerate(scan_tasks, 1):
            template = task.get('template', '')
            params = task.get('params', {})
            priority = task.get('priority', 'medium')
            reason = task.get('reason', '')

            # 生成预期的check_id
            check_id = _generate_check_id_from_task(template, params)

            # 查找对应的结果
            findings = results_by_check.get(check_id, [])
            finding_count = len(findings)
            feature_findings += finding_count

            if finding_count > 0:
                tasks_with_results += 1

            tasks_output.append({
                'task_id': idx,
                'template': template,
                'priority': priority,
                'params': params,
                'reason': reason,
                'findings': findings,
                'finding_count': finding_count
            })

        # 统计有结果的feature
        if feature_findings > 0:
            features_with_results += 1
        total_findings += feature_findings

        # 添加所有feature
        features_output.append({
            'feature_id': feature_id,
            'feature_name': feature_name,
            'risk_level': risk_level,
            'total_tasks': len(scan_tasks),
            'tasks_with_results': tasks_with_results,
            'total_findings': feature_findings,
            'tasks': tasks_output
        })

    # 构建元数据
    metadata = {
        'scan_time': datetime.now().isoformat(),
        'total_results': total_findings,
        'total_features': len(feature_risk_plan.get("features", []) or []),
        'features_with_results': features_with_results
    }

    return {
        'scan_metadata': metadata,
        'features': features_output
    }


def _generate_check_id_from_task(template: str, params: Dict) -> str:
    """根据任务模板和参数生成check_id"""
    symbol = params.get('symbol', '')
    field = params.get('field', '')
    mode = params.get('mode', 'both')
    
    # Python 模板
    if template == "PY_CALLERS_OF_FUNCTION":
        return f"tmp.py-callers-of-{symbol}"
    elif template == "PY_REFERENCES_OF_SYMBOL":
        return f"tmp.py-ref-name-{symbol}"
    elif template == "PY_FIELD_READ_WRITE_SITES":
        if mode == 'write':
            return f"tmp.py-field-write-{field}"
        elif mode == 'read':
            return f"tmp.py-field-read-{field}"
        else:
            return f"tmp.py-field-write-{field}"
    elif template == "PY_UPSTREAM_CALLGRAPH":
        return f"tmp.py-upstream-callgraph-{symbol}"
    elif template == "PY_EXCEPTION_HANDLING_AROUND_CALL":
        return f"tmp.py-exception-handling-around-{symbol}"
    elif template == "PY_ARGUMENT_SOURCES_AT_CALLSITE":
        return f"tmp.py-argument-source-{symbol}"
    elif template == "PY_RETURN_VALUE_USAGE":
        return f"tmp.py-return-value-used-{symbol}"
    
    # Java 模板
    elif template == "JAVA_CALLERS_OF_METHOD":
        return f"tmp.java-callers-of-{symbol}"
    elif template == "JAVA_METHOD_OVERRIDE":
        return f"tmp.java-method-override-{symbol}"
    elif template == "JAVA_EXCEPTION_HANDLING":
        return f"tmp.java-exception-handling-around-{symbol}"
    elif template == "JAVA_FIELD_READ_WRITE":
        if mode == 'write':
            return f"tmp.java-field-write-{field}"
        elif mode == 'read':
            return f"tmp.java-field-read-{field}"
        else:
            return f"tmp.java-field-write-{field}"
    elif template == "JAVA_ANNOTATION_USAGE":
        return f"tmp.java-annotation-usage-{symbol}"
    elif template == "JAVA_ARGUMENT_SOURCES":
        return f"tmp.java-argument-source-{symbol}"
    
    # Go 模板
    elif template == "GO_CALLERS_OF_FUNCTION":
        return f"tmp.go-callers-of-{symbol}"
    elif template == "GO_DEFER_USAGE":
        return f"tmp.go-defer-{symbol}"
    elif template == "GO_ERROR_HANDLING":
        return f"tmp.go-error-ignored-{symbol}"
    elif template == "GO_GOROUTINE_SPAWN":
        return f"tmp.go-goroutine-{symbol}"
    elif template == "GO_INTERFACE_METHOD":
        return f"tmp.go-interface-method-{symbol}"
    elif template == "GO_FIELD_READ_WRITE":
        if mode == 'write':
            return f"tmp.go-field-write-{field}"
        elif mode == 'read':
            return f"tmp.go-field-read-{field}"
        else:
            return f"tmp.go-field-write-{field}"
    
    # C 模板
    elif template == "C_CALLERS_OF_FUNCTION":
        return f"tmp.c-callers-of-{symbol}"
    elif template == "C_POINTER_OPERATIONS":
        return f"tmp.c-pointer-deref-{symbol}"
    elif template == "C_MEMORY_OPERATIONS":
        return f"tmp.c-malloc-{symbol}"
    elif template == "C_BUFFER_OPERATIONS":
        return f"tmp.c-buffer-access-{symbol}"
    elif template == "C_NULL_CHECK":
        return f"tmp.c-null-check-{symbol}"
    elif template == "C_RETURN_VALUE":
        return f"tmp.c-return-value-used-{symbol}"
    
    # Ruby 模板
    elif template == "RB_CALLERS_OF_METHOD":
        return f"tmp.rb-callers-of-{symbol}"
    elif template == "RB_METHOD_MISSING":
        return f"tmp.rb-method-missing-definition"
    elif template == "RB_EVAL_USAGE":
        return f"tmp.rb-eval-usage"
    elif template == "RB_BLOCK_USAGE":
        return f"tmp.rb-block-given-{symbol}"
    elif template == "RB_EXCEPTION_HANDLING":
        return f"tmp.rb-exception-handling-around-{symbol}"
    elif template == "RB_ATTR_ACCESS":
        return f"tmp.rb-attr-accessor-{field}"
    
    # TypeScript 模板
    elif template == "TS_CALLERS_OF_FUNCTION":
        return f"tmp.ts-callers-of-{symbol}"
    elif template == "TS_PROMISE_USAGE":
        return f"tmp.ts-promise-{symbol}"
    elif template == "TS_TYPE_ASSERTION":
        return f"tmp.ts-type-assertion-as"
    elif template == "TS_NULL_HANDLING":
        return f"tmp.ts-nullish-coalescing-{symbol}"
    elif template == "TS_DECORATOR_USAGE":
        return f"tmp.ts-decorator-{symbol}"
    elif template == "TS_EXCEPTION_HANDLING":
        return f"tmp.ts-try-catch-{symbol}"
    elif template == "TS_FIELD_READ_WRITE":
        if mode == 'write':
            return f"tmp.ts-field-write-{field}"
        elif mode == 'read':
            return f"tmp.ts-field-read-{field}"
        else:
            return f"tmp.ts-field-write-{field}"
    
    else:
        return f"tmp.{template.lower()}"