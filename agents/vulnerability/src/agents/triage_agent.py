"""
Triage Agent - 预分类与快速筛选Agent
负责快速识别需要深度审查的代码区域，提升整体审查效率
"""

import json
import logging
import re
from typing import Any, Dict, List, Optional, Tuple
from dataclasses import dataclass, field, asdict
from enum import Enum
from concurrent.futures import ThreadPoolExecutor, as_completed

from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage, HumanMessage

from ..prompts.prompt import (
    GLM_TRIAGE_AGENT_SYSTEM,
    format_glm_triage_prompt,
    validate_output_format
)

logger = logging.getLogger(__name__)


class ReviewType(Enum):
    """审查类型"""
    LOGIC = "logic"
    SECURITY = "security"
    BOTH = "both"
    NONE = "none"


class Priority(Enum):
    """优先级"""
    P0 = "P0"  # 紧急
    P1 = "P1"  # 高
    P2 = "P2"  # 中
    P3 = "P3"  # 低
    SKIP = "SKIP"  # 跳过


@dataclass
class TriageResult:
    """分类结果

    字段顺序规则：必填字段（无默认值）必须全部放在前面，可选字段（有默认值）放在后面。
    """
    # ---- 必填字段（无默认值）必须全部放最前面 ----
    hunk_id: str
    file_path: str
    should_review: bool
    priority: str

    # ---- 可选字段（有默认值）放在后面 ----
    skip_reason: Optional[str] = None
    review_types: List[str] = field(default_factory=list)
    logic_signals: List[str] = field(default_factory=list)
    security_signals: List[str] = field(default_factory=list)
    skip_signals: List[str] = field(default_factory=list)
    change_type: str = "modified"
    complexity: str = "medium"
    risk_areas: List[str] = field(default_factory=list)
    recommended_focus: str = ""

    # ---- 行范围字段（新增，用于 downstream 路由）----
    # Line range on the *new* side of the diff (right side).
    # This is the minimum information needed to support "line-level" routing
    # in later stages even when triage is rule-based.
    new_start_line: Optional[int] = None
    new_end_line: Optional[int] = None

    # (Optional) line range on the *old* side of the diff (left side).
    old_start_line: Optional[int] = None
    old_end_line: Optional[int] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


class TriageAgent:
    """Triage Agent - 代码变更预分类"""

    SKIP_FILE_PATTERNS = [
        r"test[s]?/",
        r"__tests__/",
        r"spec/",
        r"test_.*\.py$",
        r".*_test\.py$",
        r".*_test\.go$",
        r".*\.test\.(js|ts|tsx)$",
        r".*\.spec\.(js|ts|tsx)$",
        r"\.md$",
        r"\.rst$",
        r"\.txt$",
        r"README",
        r"CHANGELOG",
        r"LICENSE",
        r"package-lock\.json$",
        r"yarn\.lock$",
        r"go\.sum$",
        r"Cargo\.lock$",
        r"poetry\.lock$",
        r"\.gitignore$",
        r"\.dockerignore$",
        r"Makefile$",
        r"Dockerfile$",
        r"\.github/",
        r"\.vscode/",
        r"\.idea/",
    ]

    SECURITY_KEYWORDS = [
        "auth", "login", "logout", "session", "token", "jwt", "oauth",
        "password", "credential", "permission", "role", "rbac", "acl",
        "bearer", "cookie", "csrf", "cors",
        "input", "request", "param", "query", "body", "header", "form",
        "upload", "file", "path", "url", "redirect",
        "sql", "query", "execute", "cursor", "database", "db\\.",
        "select", "insert", "update", "delete", "where",
        "exec", "eval", "system", "popen", "subprocess", "shell",
        "command", "cmd", "spawn", "fork",
        "serialize", "deserialize", "pickle", "marshal", "yaml\\.load",
        "json\\.load", "xml", "parse",
        "encrypt", "decrypt", "hash", "md5", "sha", "aes", "rsa",
        "secret", "key", "private", "public",
        "http", "https", "request", "fetch", "curl", "socket",
        "ssrf", "proxy", "forward",
        "sensitive", "pii", "personal", "credit", "card", "ssn",
        "email", "phone", "address",
    ]

    LOGIC_KEYWORDS = [
        "if", "else", "elif", "switch", "case", "match",
        "for", "while", "loop", "iterate", "range",
        "break", "continue", "return", "yield",
        "try", "catch", "except", "finally", "throw", "raise",
        "error", "exception", "panic", "recover",
        "state", "status", "flag", "mode", "phase",
        "init", "start", "stop", "reset", "update",
        "open", "close", "acquire", "release", "lock", "unlock",
        "connect", "disconnect", "dispose", "cleanup",
        "async", "await", "thread", "process", "concurrent",
        "mutex", "semaphore", "channel", "queue",
        "atomic", "volatile", "synchronized",
        "index", "offset", "limit", "boundary", "range",
        "min", "max", "count", "size", "length",
    ]

    def __init__(self, llm: Optional[ChatOpenAI] = None, use_llm: bool = True):
        """初始化Triage Agent"""
        self.llm = llm
        self.use_llm = use_llm and llm is not None

        self._skip_patterns = [re.compile(p, re.IGNORECASE) for p in self.SKIP_FILE_PATTERNS]
        self._security_pattern = re.compile(
            r'\b(' + '|'.join(self.SECURITY_KEYWORDS) + r')\b',
            re.IGNORECASE
        )
        self._logic_pattern = re.compile(
            r'\b(' + '|'.join(self.LOGIC_KEYWORDS) + r')\b',
            re.IGNORECASE
        )
    
    def triage_hunks(self,
                     hunks: List[Dict[str, Any]],
                     parallel: bool = True,
                     max_workers: int = 4) -> Dict[str, Any]:
        """对多个hunk进行批量分类"""
        logger.info(f"[Triage Agent] 开始分类 {len(hunks)} 个hunks")

        results = []

        if parallel and len(hunks) > 1:
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                futures = {
                    executor.submit(self.triage_single_hunk, hunk): hunk
                    for hunk in hunks
                }
                for future in as_completed(futures):
                    try:
                        result = future.result()
                        results.append(result)
                    except Exception as e:
                        hunk = futures[future]
                        logger.error(f"[Triage Agent] 处理失败: {hunk.get('hunk_id')}, 错误: {e}")
                        results.append(TriageResult(
                            hunk_id=hunk.get('hunk_id', 'unknown'),
                            file_path=hunk.get('file_path', 'unknown'),
                            should_review=True,
                            priority="P2",
                            review_types=["logic", "security"]
                        ))
        else:
            for hunk in hunks:
                result = self.triage_single_hunk(hunk)
                results.append(result)

        summary = self._summarize_results(results)
        
        logger.info(f"[Triage Agent] 分类完成: "
                   f"需审查 {summary['to_review_count']}/{len(hunks)}, "
                   f"跳过 {summary['skip_count']}")
        
        return summary

    def triage_single_hunk(self, hunk: Dict[str, Any]) -> TriageResult:
        """对单个hunk进行分类"""
        hunk_id = hunk.get('hunk_id', 'unknown')
        file_path = hunk.get('file_path', '')
        diff_text = hunk.get('diff_text', '') or self._extract_diff_text(hunk)

        # Compute line ranges from diff_ir-style hunk fields when available.
        hunk_data = hunk.get("hunk", {}) or {}
        new_start = hunk.get("new_start_line") or hunk_data.get("new_start")
        new_count = hunk.get("new_count") or hunk_data.get("new_count") or 0
        old_start = hunk.get("old_start_line") or hunk_data.get("old_start")
        old_count = hunk.get("old_count") or hunk_data.get("old_count") or 0

        new_end = None
        if new_start is not None:
            try:
                new_end = int(new_start) + max(int(new_count), 1) - 1
            except Exception:
                new_end = int(new_start)

        old_end = None
        if old_start is not None:
            try:
                old_end = int(old_start) + max(int(old_count), 1) - 1
            except Exception:
                old_end = int(old_start)

        logger.debug(f"[Triage Agent] 分类 hunk: {hunk_id}")

        rule_result = self._rule_based_triage(hunk_id, file_path, diff_text)

        # Always keep hunk identity + line ranges, even for rule-based triage.
        rule_result.hunk_id = hunk_id
        rule_result.file_path = file_path
        rule_result.new_start_line = int(new_start) if new_start is not None else None
        rule_result.new_end_line = int(new_end) if new_end is not None else None
        rule_result.old_start_line = int(old_start) if old_start is not None else None
        rule_result.old_end_line = int(old_end) if old_end is not None else None

        if rule_result.priority == "SKIP":
            return rule_result

        if rule_result.priority in ["P0", "P1"]:
            return rule_result

        if self.use_llm and self._should_use_llm(rule_result):
            llm_result = self._llm_based_triage(hunk)
            if llm_result:
                merged = self._merge_results(rule_result, llm_result)
                # Ensure identity/range fields survive merges.
                merged.hunk_id = hunk_id
                merged.file_path = file_path
                merged.new_start_line = rule_result.new_start_line
                merged.new_end_line = rule_result.new_end_line
                merged.old_start_line = rule_result.old_start_line
                merged.old_end_line = rule_result.old_end_line
                return merged

        return rule_result

    def _rule_based_triage(self, hunk_id: str, file_path: str, diff_text: str) -> TriageResult:
        """基于规则的快速分类"""
        skip_signals = []
        logic_signals = []
        security_signals = []

        for pattern in self._skip_patterns:
            if pattern.search(file_path):
                skip_signals.append(f"匹配跳过模式: {pattern.pattern}")

        if self._is_comment_only_change(diff_text):
            skip_signals.append("纯注释修改")

        if self._is_whitespace_only_change(diff_text):
            skip_signals.append("纯空白变更")

        if skip_signals:
            return TriageResult(
                hunk_id=hunk_id,
                file_path=file_path,
                should_review=False,
                skip_reason="; ".join(skip_signals[:3]),
                priority="SKIP",
                skip_signals=skip_signals
            )
        
        # 检查安全相关信号
        security_matches = self._security_pattern.findall(diff_text)
        if security_matches:
            unique_matches = list(set(m.lower() for m in security_matches))
            security_signals = unique_matches[:10]
        
        # 检查逻辑相关信号
        logic_matches = self._logic_pattern.findall(diff_text)
        if logic_matches:
            unique_matches = list(set(m.lower() for m in logic_matches))
            logic_signals = unique_matches[:10]
        
        # 确定审查类型
        review_types = []
        if security_signals:
            review_types.append("security")
        if logic_signals:
            review_types.append("logic")
        
        # 如果没有任何信号，默认需要逻辑审查
        if not review_types:
            review_types = ["logic"]
        
        # 评估优先级
        priority = self._calculate_priority(
            security_signals, logic_signals, diff_text
        )
        
        # 评估复杂度
        complexity = self._assess_complexity(diff_text)
        
        # 识别风险区域
        risk_areas = self._identify_risk_areas(security_signals, logic_signals)
        
        return TriageResult(
            hunk_id=hunk_id,
            file_path=file_path,
            should_review=True,
            review_types=review_types,
            priority=priority,
            logic_signals=logic_signals,
            security_signals=security_signals,
            complexity=complexity,
            risk_areas=risk_areas,
            recommended_focus=self._generate_focus_hint(security_signals, logic_signals)
        )
    
    def _llm_based_triage(self, hunk: Dict[str, Any]) -> Optional[TriageResult]:
        """
        使用LLM进行辅助分类
        """
        try:
            # 构建提示词
            user_prompt = format_glm_triage_prompt(hunk)
            
            # 调用LLM
            messages = [
                SystemMessage(content=GLM_TRIAGE_AGENT_SYSTEM),
                HumanMessage(content=user_prompt)
            ]
            
            response = self.llm.invoke(messages)
            response_text = response.content
            
            # 解析结果
            parsed = validate_output_format(response_text, "triage")
            
            if parsed.get("success"):
                data = parsed["data"].get("triage_result", {})
                return TriageResult(
                    hunk_id=hunk.get("hunk_id", ""),
                    file_path=hunk.get("file_path", ""),
                    should_review=data.get("should_review", True),
                    skip_reason=data.get("skip_reason"),
                    review_types=data.get("review_types", ["logic"]),
                    priority=data.get("priority", "P2"),
                    logic_signals=data.get("signals", {}).get("logic_signals", []),
                    security_signals=data.get("signals", {}).get("security_signals", []),
                    skip_signals=data.get("signals", {}).get("skip_signals", []),
                    change_type=data.get("quick_assessment", {}).get("change_type", "modified"),
                    complexity=data.get("quick_assessment", {}).get("complexity", "medium"),
                    risk_areas=data.get("quick_assessment", {}).get("risk_areas", []),
                    recommended_focus=data.get("recommended_focus", "")
                )
            
        except Exception as e:
            logger.warning(f"[Triage Agent] LLM分类失败: {e}")
        
        return None
    
    def _merge_results(self, rule_result: TriageResult, 
                       llm_result: TriageResult) -> TriageResult:
        """
        合并规则结果和LLM结果
        """
        # 优先使用LLM的判断，但保留规则发现的信号
        merged = llm_result
        merged.logic_signals = list(set(
            rule_result.logic_signals + llm_result.logic_signals
        ))
        merged.security_signals = list(set(
            rule_result.security_signals + llm_result.security_signals
        ))
        
        # 如果规则发现了LLM没发现的安全信号，提升优先级
        if rule_result.security_signals and not llm_result.security_signals:
            if merged.priority in ["P2", "P3"]:
                merged.priority = "P1"
            merged.review_types = list(set(merged.review_types + ["security"]))
        
        return merged
    
    def _should_use_llm(self, rule_result: TriageResult) -> bool:
        """
        判断是否需要使用LLM辅助
        """
        # P2/P3优先级且信号不明确时使用LLM
        if rule_result.priority in ["P2", "P3"]:
            total_signals = len(rule_result.logic_signals) + len(rule_result.security_signals)
            if total_signals < 3:
                return True
        return False
    
    def _is_comment_only_change(self, diff_text: str) -> bool:
        """检查是否为纯注释修改"""
        lines = diff_text.split('\n')
        for line in lines:
            stripped = line.strip()
            if stripped.startswith('+') or stripped.startswith('-'):
                content = stripped[1:].strip()
                if content and not self._is_comment_line(content):
                    return False
        return True
    
    def _is_comment_line(self, line: str) -> bool:
        """检查是否为注释行"""
        comment_patterns = [
            r'^#',           # Python, Shell
            r'^//',          # C, C++, Java, JS
            r'^/\*',         # C-style block comment
            r'^\*',          # Inside block comment
            r'^\*/',         # End block comment
            r'^"""',         # Python docstring
            r"^'''",         # Python docstring
            r'^<!--',        # HTML comment
            r'^--',          # SQL comment
        ]
        for pattern in comment_patterns:
            if re.match(pattern, line.strip()):
                return True
        return False
    
    def _is_whitespace_only_change(self, diff_text: str) -> bool:
        """检查是否为纯空白变更"""
        lines = diff_text.split('\n')
        for line in lines:
            if line.startswith('+') or line.startswith('-'):
                content = line[1:]
                if content.strip():
                    return False
        return True
    
    def _calculate_priority(self, security_signals: List[str],
                           logic_signals: List[str],
                           diff_text: str) -> str:
        """计算优先级"""
        # 计算变更量
        lines = diff_text.split('\n')
        add_lines = sum(1 for l in lines if l.startswith('+'))
        del_lines = sum(1 for l in lines if l.startswith('-'))
        total_changes = add_lines + del_lines
        
        # 高危安全关键词
        high_risk_security = ["auth", "login", "password", "token", "sql", "exec", "eval"]
        has_high_risk = any(s in high_risk_security for s in security_signals)
        
        # P0: 高危安全 + 大量变更
        if has_high_risk and total_changes > 50:
            return "P0"
        
        # P1: 安全相关 或 大量逻辑变更
        if security_signals or (logic_signals and total_changes > 30):
            return "P1"
        
        # P2: 一般逻辑变更
        if logic_signals:
            return "P2"
        
        # P3: 小量变更
        if total_changes < 10:
            return "P3"
        
        return "P2"
    
    def _assess_complexity(self, diff_text: str) -> str:
        """评估复杂度"""
        lines = diff_text.split('\n')
        change_lines = [l for l in lines if l.startswith('+') or l.startswith('-')]
        
        if len(change_lines) > 100:
            return "high"
        elif len(change_lines) > 30:
            return "medium"
        else:
            return "low"
    
    def _identify_risk_areas(self, security_signals: List[str],
                            logic_signals: List[str]) -> List[str]:
        """识别风险区域"""
        areas = []
        
        security_areas = {
            "auth": "认证逻辑",
            "login": "登录功能",
            "password": "密码处理",
            "token": "令牌管理",
            "sql": "数据库操作",
            "exec": "命令执行",
            "eval": "动态执行",
            "upload": "文件上传",
            "redirect": "URL重定向",
        }
        
        logic_areas = {
            "loop": "循环逻辑",
            "if": "条件分支",
            "try": "异常处理",
            "lock": "并发控制",
            "open": "资源管理",
        }
        
        for signal in security_signals:
            for key, area in security_areas.items():
                if key in signal.lower() and area not in areas:
                    areas.append(area)
        
        for signal in logic_signals:
            for key, area in logic_areas.items():
                if key in signal.lower() and area not in areas:
                    areas.append(area)
        
        return areas[:5]
    
    def _generate_focus_hint(self, security_signals: List[str],
                            logic_signals: List[str]) -> str:
        """生成关注点提示"""
        hints = []
        
        if security_signals:
            hints.append(f"安全: {', '.join(security_signals[:3])}")
        
        if logic_signals:
            hints.append(f"逻辑: {', '.join(logic_signals[:3])}")
        
        return "; ".join(hints)[:100]
    
    def _extract_diff_text(self, hunk: Dict[str, Any]) -> str:
        """从hunk中提取diff文本"""
        if "diff_hunk" in hunk:
            return hunk["diff_hunk"]
        
        hunk_data = hunk.get("hunk", {})
        if "lines" in hunk_data:
            lines = []
            for line in hunk_data["lines"]:
                content = line.get("content", "")
                line_type = line.get("type", "context")
                if line_type == "add":
                    lines.append(f"+{content}")
                elif line_type == "del":
                    lines.append(f"-{content}")
                else:
                    lines.append(f" {content}")
            return "\n".join(lines)
        
        return ""
    
    def _summarize_results(self, results: List[TriageResult]) -> Dict[str, Any]:
        """汇总分类结果"""
        to_review = [r for r in results if r.should_review]
        skipped = [r for r in results if not r.should_review]
        
        # 按优先级分组
        by_priority = {}
        for r in to_review:
            priority = r.priority
            if priority not in by_priority:
                by_priority[priority] = []
            by_priority[priority].append(r)
        
        # 按审查类型分组
        logic_only = [r for r in to_review if r.review_types == ["logic"]]
        security_only = [r for r in to_review if r.review_types == ["security"]]
        both = [r for r in to_review if "logic" in r.review_types and "security" in r.review_types]
        
        return {
            "total_count": len(results),
            "to_review_count": len(to_review),
            "skip_count": len(skipped),
            "by_priority": {
                p: [r.to_dict() for r in rs] 
                for p, rs in by_priority.items()
            },
            "by_review_type": {
                "logic_only": len(logic_only),
                "security_only": len(security_only),
                "both": len(both)
            },
            "to_review": [r.to_dict() for r in to_review],
            "skipped": [r.to_dict() for r in skipped],
            "priority_order": ["P0", "P1", "P2", "P3"]
        }
    
    def get_review_targets(self, 
                          triage_summary: Dict[str, Any],
                          review_type: str = "all",
                          max_count: Optional[int] = None) -> List[Dict[str, Any]]:
        """
        获取需要审查的目标列表
        
        Args:
            triage_summary: triage_hunks的返回结果
            review_type: 审查类型 ("logic", "security", "all")
            max_count: 最大数量限制
        
        Returns:
            按优先级排序的审查目标列表
        """
        targets = []
        
        for priority in ["P0", "P1", "P2", "P3"]:
            priority_items = triage_summary.get("by_priority", {}).get(priority, [])
            
            for item in priority_items:
                if review_type == "all":
                    targets.append(item)
                elif review_type in item.get("review_types", []):
                    targets.append(item)
                elif review_type == "both" and len(item.get("review_types", [])) > 1:
                    targets.append(item)
            
            if max_count and len(targets) >= max_count:
                break
        
        return targets[:max_count] if max_count else targets


def run_triage_for_pr(llm: ChatOpenAI,
                      diff_ir: Dict[str, Any],
                      feature_risk_plan: Dict[str, Any],
                      use_llm: bool = False,
                      max_workers: int = 4) -> Dict[str, Any]:
    """
    对PR执行Triage分类
    
    Args:
        llm: 语言模型实例
        diff_ir: diff IR数据
        feature_risk_plan: 风险计划数据
        use_llm: 是否使用LLM辅助
        max_workers: 最大并行数
    
    Returns:
        分类结果
    """
    from ..analysis.hunk_index import build_hunk_index, hunk_text_from_diff_hunk
    
    logger.info("[Triage] 开始PR预分类")
    
    # 构建hunk索引
    hunk_index = build_hunk_index(diff_ir)
    logger.info(f"[Triage] 共 {len(hunk_index)} 个hunks")
    
    # 准备hunk列表
    hunks = []
    for hunk_id, hunk_detail in hunk_index.items():
        hunk_data = hunk_detail.get("hunk", {})
        diff_text = hunk_text_from_diff_hunk(hunk_data)
        
        hunks.append({
            "hunk_id": hunk_id,
            "file_path": hunk_detail.get("file_path", ""),
            "language": hunk_detail.get("language", "Unknown"),
            "diff_text": diff_text,
            "hunk": hunk_data
        })
    
    # 执行分类
    agent = TriageAgent(llm=llm, use_llm=use_llm)
    result = agent.triage_hunks(hunks, parallel=True, max_workers=max_workers)
    
    logger.info(f"[Triage] 分类完成")
    
    return result
