"""
Logic Agent - é€»è¾‘ç¼ºé™·å®¡è®¡ä¸“ç”¨Agent
ä¸“é—¨è´Ÿè´£å‘ç°ç”±æœ¬æ¬¡PR diffå¼•å…¥æˆ–ä¿®æ”¹å¯¼è‡´çš„é€»è¾‘é”™è¯¯
"""

import json
import logging
import os
import traceback
from typing import Any, Dict, List, Optional

from langchain_core.messages import SystemMessage, HumanMessage
from langchain_openai import ChatOpenAI

from ..scripts.todolist.todolist_generator import create_code_tools_for_pr
from ..analysis.hunk_index import build_hunk_index, select_logic_targets, build_audit_unit_from_hunk

logger = logging.getLogger(__name__)

import os
from ..prompts.prompt import LOGIC_AGENT_SYSTEM, LOGIC_AGENT_SYSTEM_ENHANCED, format_logic_agent_prompt

# ç¯å¢ƒå˜é‡æ§åˆ¶ä½¿ç”¨å“ªä¸ªç‰ˆæœ¬çš„æç¤ºè¯
USE_ENHANCED_LOGIC_PROMPT = os.getenv("USE_ENHANCED_LOGIC_PROMPT", "true").lower() == "true"

# æ ¹æ®é…ç½®é€‰æ‹©æç¤ºè¯ç‰ˆæœ¬
_CURRENT_LOGIC_AGENT_SYSTEM = LOGIC_AGENT_SYSTEM_ENHANCED if USE_ENHANCED_LOGIC_PROMPT else LOGIC_AGENT_SYSTEM

if USE_ENHANCED_LOGIC_PROMPT:
    logger.info(f"[Logic Agent] ä½¿ç”¨å¢å¼ºç‰ˆæç¤ºè¯ï¼ˆç¼“å­˜/å¹¶å‘/è¾¹ç•Œå€¼/ç±»å‹å®‰å…¨ä¸“é¡¹æ£€æµ‹ï¼‰")
else:
    logger.info(f"[Logic Agent] ä½¿ç”¨æ ‡å‡†ç‰ˆæç¤ºè¯")


def _safe_json_loads(text: str) -> Dict[str, Any]:
    """
    å°½é‡ä»æ¨¡å‹è¾“å‡ºä¸­æå– JSONï¼ˆå®¹å¿å‰åæ‚è´¨ï¼‰ã€‚
    """
    text = text.strip()
    if text.startswith("{") and text.endswith("}"):
        return json.loads(text)
    l = text.find("{")
    r = text.rfind("}")
    if l != -1 and r != -1 and r > l:
        return json.loads(text[l:r+1])
    raise json.JSONDecodeError("no json object", text, 0)


def _build_logic_audit_units(feature_risk_plan: Dict[str, Any],
                             diff_ir: Dict[str, Any],
                             pr_dir: str,
                             risk_threshold: int = 60,
                             max_units: int = 12,
                             codebase_path: Optional[str] = None) -> List[Dict[str, Any]]:
    """
    ä½¿ç”¨æ–°çš„hunkç´¢å¼•ç³»ç»Ÿæ„å»ºé€»è¾‘å®¡è®¡å•å…ƒã€‚
    è§£å†³å­—æ®µä¸åŒ¹é…é—®é¢˜ï¼Œç¡®ä¿Logic Agentèƒ½æ‰¾åˆ°å®¡è®¡å•å…ƒã€‚
    """
    logger.info(f"[Logic Agent] å¼€å§‹æ„å»ºå®¡è®¡å•å…ƒï¼Œé£é™©é˜ˆå€¼: {risk_threshold}, æœ€å¤§å•å…ƒæ•°: {max_units}")

    # å¤ç”¨ä½ é¡¹ç›®é‡Œçš„ code_toolsï¼ˆèƒ½ read_file/search_code/find_functionï¼‰
    tools_bundle = create_code_tools_for_pr(pr_dir, feature_risk_plan, codebase_path)
    code_tools = tools_bundle["code_tools"]

    # æ„å»ºhunkç´¢å¼• - å»ºç«‹feature_risk_planä¸diff_irä¹‹é—´çš„æ˜ å°„
    logger.info("[Logic Agent] æ„å»ºhunkç´¢å¼•æ˜ å°„")
    hunk_index = build_hunk_index(diff_ir)
    logger.info(f"[Logic Agent] ç´¢å¼•æ„å»ºå®Œæˆï¼Œå…± {len(hunk_index)} ä¸ªhunks")

    # é€‰æ‹©Logic Agentçš„ç›®æ ‡hunks
    logger.info("[Logic Agent] é€‰æ‹©Logic Agentç›®æ ‡hunks")
    logic_targets = select_logic_targets(
        feature_risk_plan=feature_risk_plan,
        risk_threshold=risk_threshold,
        max_units=max_units
    )

    logger.info(f"[Logic Agent] é€‰æ‹©äº† {len(logic_targets)} ä¸ªé€»è¾‘ç›®æ ‡hunks")

    if not logic_targets:
        logger.warning("[Logic Agent] æ²¡æœ‰æ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„é€»è¾‘ç›®æ ‡hunks")
        return []

    units: List[Dict[str, Any]] = []
    total_targets = len(logic_targets)
    processed_targets = 0
    skipped_targets = 0

    for target_info in logic_targets:
        hunk_id = target_info.get("hunk_id")
        if not hunk_id:
            skipped_targets += 1
            logger.debug("[Logic Agent] è·³è¿‡target: æ— hunk_id")
            continue

        # ä»ç´¢å¼•ä¸­è·å–hunkè¯¦æƒ…
        hunk_detail = hunk_index.get(hunk_id)
        if not hunk_detail:
            skipped_targets += 1
            logger.warning(f"[Logic Agent] hunk_id {hunk_id} åœ¨ç´¢å¼•ä¸­ä¸å­˜åœ¨")
            continue

        processed_targets += 1
        file_path = hunk_detail.get("file_path")
        risk_score = target_info.get("risk_score", 0)
        selection_reason = target_info.get("reason", "unknown")

        logger.debug(f"[Logic Agent] å¤„ç†ç›®æ ‡ {processed_targets}/{total_targets}: {hunk_id} "
                    f"(æ–‡ä»¶: {file_path}, åˆ†æ•°: {risk_score}, åŸå› : {selection_reason})")

        try:
            # ä½¿ç”¨hunk_indexä¸­çš„å‡½æ•°æ„å»ºå®¡è®¡å•å…ƒ
            audit_unit = build_audit_unit_from_hunk(
                hunk_id=hunk_id,
                hunk=hunk_detail,
                code_tools=code_tools,
                target_info=target_info
            )

            units.append(audit_unit)
            logger.info(f"[{len(units)}/{max_units}] å·²åˆ›å»ºé€»è¾‘å®¡è®¡å•å…ƒ: {hunk_id} "
                       f"(é£é™©åˆ†æ•°: {risk_score}, é€‰æ‹©åŸå› : {selection_reason})")

            if len(units) >= max_units:
                logger.info(f"[Logic Agent] è¾¾åˆ°æœ€å¤§å•å…ƒæ•°é™åˆ¶: {max_units}")
                break

        except Exception as e:
            skipped_targets += 1
            logger.error(f"[Logic Agent] æ„å»ºå®¡è®¡å•å…ƒå¤±è´¥ {hunk_id}: {str(e)}")
            continue

    logger.info(f"[Logic Agent] é€»è¾‘å®¡è®¡å•å…ƒæ„å»ºå®Œæˆ")
    logger.info(f"[Logic Agent] æ€»ç›®æ ‡: {total_targets}, å¤„ç†æˆåŠŸ: {processed_targets}, è·³è¿‡: {skipped_targets}")
    logger.info(f"[Logic Agent] æœ€ç»ˆç”Ÿæˆå•å…ƒ: {len(units)}")

    return units


def _match_semgrep_findings_to_unit(audit_unit: Dict[str, Any],
                                     template_findings: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    æŒ‰åŠŸèƒ½å—åŒ¹é… Semgrep è¯æ®åˆ°å®¡è®¡å•å…ƒ

    åŒ¹é…è§„åˆ™:
    1. ç›¸åŒæ–‡ä»¶è·¯å¾„ (file_path)
    2. è¡Œå·èŒƒå›´é‡å  (modified_lines ä¸ Semgrep findings çš„ line_start/line_end)
    3. å¯é€‰: ç›¸åŒåŠŸèƒ½å (feature_name)

    Args:
        audit_unit: å®¡è®¡å•å…ƒ
        template_findings: Semgrep æ‰«æå‘ç°åˆ—è¡¨

    Returns:
        åŒ¹é…çš„ Semgrep å‘ç°åˆ—è¡¨
    """
    unit_file = audit_unit.get("file_path", "")
    unit_feature = audit_unit.get("feature_name", "")

    # è·å–ä¿®æ”¹çš„è¡Œå·èŒƒå›´
    modified_lines = audit_unit.get("code_context", {}).get("modified_lines", [])
    if not modified_lines:
        return []

    unit_line_min = min(modified_lines)
    unit_line_max = max(modified_lines)

    matched_findings = []

    for finding in template_findings:
        finding_file = finding.get("file_path", "")

        # è§„åˆ™1: æ–‡ä»¶è·¯å¾„å¿…é¡»åŒ¹é…
        if finding_file != unit_file:
            continue

        # è§„åˆ™2: è¡Œå·èŒƒå›´å¿…é¡»é‡å 
        finding_line_start = finding.get("line_start", 0)
        finding_line_end = finding.get("line_end", finding_line_start)

        # æ£€æŸ¥æ˜¯å¦æœ‰é‡å 
        if not (finding_line_end < unit_line_min or finding_line_start > unit_line_max):
            # æœ‰é‡å ,åŒ¹é…æˆåŠŸ
            matched_findings.append(finding)

    logger.debug(f"[_match_semgrep] å•å…ƒ {audit_unit.get('hunk_id')}: "
                f"æ–‡ä»¶={unit_file}, è¡Œ={unit_line_min}-{unit_line_max}, "
                f"åŒ¹é…={len(matched_findings)}/{len(template_findings)}")

    return matched_findings


def run_logic_agent_for_pr(pr_dir: str,
                           diff_ir: Dict[str, Any],
                           feature_risk_plan: Dict[str, Any],
                           llm: ChatOpenAI,
                           risk_threshold: int = 60,
                           max_units: int = 12,
                           template_findings: List[Dict[str, Any]] = None,
                           codebase_path: Optional[str] = None) -> Dict[str, Any]:
    """
    PR çº§é€»è¾‘ç¼ºé™·å®¡è®¡å…¥å£ï¼šæŒ‘é€‰é‡ç‚¹ hunks -> è°ƒç”¨ Logic Agent -> æ±‡æ€»ç»“æœ

    Args:
        template_findings: Semgrep æ‰«æå‘ç°åˆ—è¡¨ (æŒ‰åŠŸèƒ½å—åˆ†ç»„)
        codebase_path: å…‹éš†çš„æºä»£ç è·¯å¾„ï¼ˆä¼˜å…ˆä½¿ç”¨ï¼‰
    """
    logger.info(f"[Logic Agent] å¼€å§‹PRçº§é€»è¾‘ç¼ºé™·å®¡è®¡")
    logger.info(f"[Logic Agent] å‚æ•°: é£é™©é˜ˆå€¼={risk_threshold}, æœ€å¤§å•å…ƒ={max_units}")

    # ğŸ†• è®°å½• Semgrep è¯æ®
    if template_findings:
        logger.info(f"[Logic Agent] æ”¶åˆ° {len(template_findings)} ä¸ª Semgrep å‘ç°")
    else:
        logger.info(f"[Logic Agent] æ—  Semgrep è¯æ®")

    audit_units = _build_logic_audit_units(
        feature_risk_plan=feature_risk_plan,
        diff_ir=diff_ir,
        pr_dir=pr_dir,
        risk_threshold=risk_threshold,
        max_units=max_units,
        codebase_path=codebase_path
    )

    if not audit_units:
        logger.info("[Logic Agent] æ²¡æœ‰éœ€è¦åˆ†æçš„å®¡è®¡å•å…ƒ")
        return {
            "success": True,
            "units_analyzed": 0,
            "issues_found": 0,
            "issues": [],
            "raw_results": [],
            "errors": []
        }

    logger.info(f"[Logic Agent] å¼€å§‹é€ä¸ªåˆ†æ {len(audit_units)} ä¸ªå®¡è®¡å•å…ƒ")

    results: List[Dict[str, Any]] = []
    errors: List[str] = []
    success_count = 0
    no_issue_count = 0
    issue_count = 0

    for i, unit in enumerate(audit_units, 1):
        hunk_id = unit.get("hunk_id", "unknown")
        file_path = unit.get("file_path", "unknown")
        risk_score = unit.get("risk_score", 0)
        symbol_name = unit.get("symbol_name", "")
        modified_lines = unit.get("code_context", {}).get("modified_lines", [])
        feature_name = unit.get("feature_name", "")  # ğŸ†• è·å–åŠŸèƒ½å

        logger.info(f"[Logic Agent] [{i}/{len(audit_units)}] åˆ†æhunk: {hunk_id} (æ–‡ä»¶: {file_path}, åˆ†æ•°: {risk_score}, ç¬¦å·: {symbol_name})")

        # ğŸ†• æŒ‰åŠŸèƒ½å—åŒ¹é… Semgrep è¯æ®
        unit_semgrep_findings = []
        if template_findings:
            unit_semgrep_findings = _match_semgrep_findings_to_unit(
                unit, template_findings
            )
            if unit_semgrep_findings:
                logger.info(f"[Logic Agent] {hunk_id}: åŒ¹é…åˆ° {len(unit_semgrep_findings)} ä¸ª Semgrep å‘ç°")

        try:
            # ğŸ”§ ç¬¬äºŒæ­¥ï¼šåŸºäº Semgrep è¯æ®è¿›è¡ŒLLMåˆ†æ
            # ğŸ†• æ³¨å…¥ Semgrep è¯æ®åˆ°æç¤ºè¯
            prompt = format_logic_agent_prompt(unit, semgrep_findings=unit_semgrep_findings)
            messages = [
                SystemMessage(content=_CURRENT_LOGIC_AGENT_SYSTEM),
                HumanMessage(content=prompt)
            ]

            # åªåœ¨å¯ç”¨è¯¦ç»†æ—¥å¿—æ—¶è®°å½•LLMäº¤äº’
            if os.getenv("ENABLE_DETAILED_LOGS", "false").lower() == "true":
                logger.debug(f"[Logic Agent] {hunk_id}: å¼€å§‹LLMè°ƒç”¨")
                logger.debug(f"[Logic Agent] {hunk_id}: è¾“å…¥prompté•¿åº¦: {len(prompt)} å­—ç¬¦")

                # è®°å½•å®Œæ•´çš„è¾“å…¥ï¼ˆæˆªæ–­è¿‡é•¿å†…å®¹ï¼‰
                prompt_preview = prompt[:1000] + "..." if len(prompt) > 1000 else prompt
                logger.debug(f"[Logic Agent] {hunk_id}: LLMè¾“å…¥:\n{prompt_preview}")

            # Retry logic for LLM calls with null response handling
            max_retries = 3
            text = None
            for attempt in range(max_retries):
                try:
                    resp = llm.invoke(messages)
                    text = resp.content if hasattr(resp, "content") else str(resp)
                    if text:
                        break
                except TypeError as e:
                    if "null value for `choices`" in str(e):
                        import time
                        logger.warning(f"[Logic Agent] {hunk_id}: LLMè¿”å›null choicesï¼Œé‡è¯• {attempt + 1}/{max_retries}")
                        time.sleep(1)
                        continue
                    raise
                except Exception as e:
                    logger.warning(f"[Logic Agent] {hunk_id}: LLMè°ƒç”¨å¤±è´¥ï¼Œé‡è¯• {attempt + 1}/{max_retries}: {str(e)}")
                    import time
                    time.sleep(1)
                    continue
            
            if not text:
                # Fallback when LLM is unavailable
                logger.warning(f"[Logic Agent] {hunk_id}: LLMè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨fallbackç»“æœ")
                success_count += 1
                no_issue_count += 1
                continue

            # åªåœ¨å¯ç”¨è¯¦ç»†æ—¥å¿—æ—¶è®°å½•LLMè¾“å‡º
            if os.getenv("ENABLE_DETAILED_LOGS", "false").lower() == "true":
                logger.debug(f"[Logic Agent] {hunk_id}: LLMè¾“å‡ºé•¿åº¦: {len(text)} å­—ç¬¦")

                # è®°å½•å®Œæ•´çš„è¾“å‡ºï¼ˆæˆªæ–­è¿‡é•¿å†…å®¹ï¼‰
                output_preview = text[:2000] + "..." if len(text) > 2000 else text
                logger.debug(f"[Logic Agent] {hunk_id}: LLMè¾“å‡º:\n{output_preview}")

            obj = _safe_json_loads(text)

            # è½»é‡æ ¡éªŒï¼šå¿…é¡»æœ‰ result å­—æ®µ
            if obj.get("result") not in ("NO_ISSUE", "ISSUE"):
                logger.warning(f"[Logic Agent] {hunk_id}: è¾“å‡ºæ ¼å¼æ— æ•ˆï¼Œè®¾ç½®ä¸ºNO_ISSUE")
                logger.warning(f"[Logic Agent] {hunk_id}: æ— æ•ˆè¾“å‡ºå†…å®¹: {obj}")
                obj = {
                    "result": "NO_ISSUE",
                    "issue": None,
                    "need_context": ["model_output_schema_invalid"]
                }
                success_count += 1
                no_issue_count += 1
            elif obj.get("result") == "ISSUE":
                issue_title = obj.get("issue", {}).get("title", "æœªçŸ¥é—®é¢˜")
                issue_severity = obj.get("issue", {}).get("severity", "unknown")
                logger.info(f"[Logic Agent] {hunk_id}: å‘ç°é—®é¢˜ - {issue_title} ({issue_severity})")

                # è¯¦ç»†è®°å½•å‘ç°çš„é—®é¢˜
                issue_data = obj.get("issue", {})
                if os.getenv("ENABLE_DETAILED_LOGS", "false").lower() == "true":
                    logger.debug(f"[Logic Agent] {hunk_id}: é—®é¢˜è¯¦æƒ…:\n" + json.dumps(issue_data, indent=2, ensure_ascii=False))

                success_count += 1
                issue_count += 1
            else:
                logger.debug(f"[Logic Agent] {hunk_id}: æ— é—®é¢˜")
                need_context = obj.get("need_context", [])
                if need_context and os.getenv("ENABLE_DETAILED_LOGS", "false").lower() == "true":
                    logger.debug(f"[Logic Agent] {hunk_id}: éœ€è¦æ›´å¤šä¸Šä¸‹æ–‡: {need_context}")
                success_count += 1
                no_issue_count += 1

            # æŒ‚ä¸Šå®šä½ä¿¡æ¯ï¼Œæ–¹ä¾¿æœ€ç»ˆæŠ¥å‘Šå‘ˆç°
            obj["_meta"] = {
                "hunk_id": hunk_id,
                "file_path": file_path,
                "risk_score": risk_score,
            }
            results.append(obj)

        except Exception as e:
            error_msg = f"hunk_id={hunk_id} error={str(e)}"
            logger.error(f"[Logic Agent] {hunk_id}: åˆ†æå¤±è´¥ - {str(e)}")
            logger.error(f"[Logic Agent] {hunk_id}: å¼‚å¸¸è¯¦æƒ…: {traceback.format_exc()}")
            errors.append(error_msg)

    issues = [r for r in results if r.get("result") == "ISSUE"]

    # æœ€ç»ˆç»Ÿè®¡
    logger.info(f"[Logic Agent] åˆ†æå®Œæˆç»Ÿè®¡:")
    logger.info(f"[Logic Agent] æˆåŠŸ: {success_count}/{len(audit_units)}")
    logger.info(f"[Logic Agent] å‘ç°é—®é¢˜: {issue_count}")
    logger.info(f"[Logic Agent] æ— é—®é¢˜: {no_issue_count}")
    logger.info(f"[Logic Agent] æ‰§è¡Œé”™è¯¯: {len(errors)}")

    return {
        "success": True,
        "units_analyzed": len(audit_units),
        "issues_found": len(issues),
        "issues": issues,
        "raw_results": results,
        "errors": errors
    }