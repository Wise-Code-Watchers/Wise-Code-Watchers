"""LLM 扫描任务规划器

目标：在执行工具扫描（Semgrep模板扫描）前，用 LLM 输出严格 JSON，
为每个 feature 生成可执行的模板扫描任务，并回填到 pr_dir/out/feature_risk_plan.json。

设计原则：
- JSON-only 输出（不允许 Markdown 代码块）
- 任务可被脚本直接执行（模板名 + 参数）
- 失败时降级：不阻断后续扫描
"""

from __future__ import annotations

import json
import os
from datetime import datetime
from typing import Any, Dict, List, Tuple

from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage, HumanMessage


# 允许的模板集合（与 template_semgrep_scanner.py 一致）
# 按语言分组的模板列表
ALLOWED_TEMPLATES = [
    # Python 模板
    "PY_CALLERS_OF_FUNCTION",
    "PY_UPSTREAM_CALLGRAPH",
    "PY_RETURN_VALUE_USAGE",
    "PY_EXCEPTION_HANDLING_AROUND_CALL",
    "PY_REFERENCES_OF_SYMBOL",
    "PY_FIELD_READ_WRITE_SITES",
    "PY_ARGUMENT_SOURCES_AT_CALLSITE",
    # Java 模板
    "JAVA_CALLERS_OF_METHOD",
    "JAVA_METHOD_OVERRIDE",
    "JAVA_EXCEPTION_HANDLING",
    "JAVA_FIELD_READ_WRITE",
    "JAVA_ANNOTATION_USAGE",
    "JAVA_ARGUMENT_SOURCES",
    # Go 模板
    "GO_CALLERS_OF_FUNCTION",
    "GO_DEFER_USAGE",
    "GO_ERROR_HANDLING",
    "GO_GOROUTINE_SPAWN",
    "GO_INTERFACE_METHOD",
    "GO_FIELD_READ_WRITE",
    # C 模板
    "C_CALLERS_OF_FUNCTION",
    "C_POINTER_OPERATIONS",
    "C_MEMORY_OPERATIONS",
    "C_BUFFER_OPERATIONS",
    "C_NULL_CHECK",
    "C_RETURN_VALUE",
    # Ruby 模板
    "RB_CALLERS_OF_METHOD",
    "RB_METHOD_MISSING",
    "RB_EVAL_USAGE",
    "RB_BLOCK_USAGE",
    "RB_EXCEPTION_HANDLING",
    "RB_ATTR_ACCESS",
    # TypeScript 模板
    "TS_CALLERS_OF_FUNCTION",
    "TS_PROMISE_USAGE",
    "TS_TYPE_ASSERTION",
    "TS_NULL_HANDLING",
    "TS_DECORATOR_USAGE",
    "TS_EXCEPTION_HANDLING",
    "TS_FIELD_READ_WRITE",
]

# 语言到模板前缀的映射
LANGUAGE_TEMPLATE_PREFIX = {
    "python": "PY_",
    "java": "JAVA_",
    "go": "GO_",
    "c": "C_",
    "cpp": "C_",  # C++使用C模板
    "ruby": "RB_",
    "typescript": "TS_",
    "javascript": "TS_",  # JavaScript使用TypeScript模板
}


SYSTEM_PROMPT = """你是代码审计系统的【扫描任务规划 Agent】。

你的输出将被下游脚本直接执行，请严格遵守：
- 只输出严格 JSON（不要代码块、不要解释）
- 只规划【逻辑漏洞相关的语义扫描任务】，不做漏洞判断、不提供修复建议
- 你的任务是：针对每个 feature，基于该 feature 的 hunks 以及风险描述，提取需要扫描的【符号/字段】，并选择合适的模板生成扫描任务。
- 重要：根据代码的语言选择对应语言的模板！

【Python 模板】
- PY_CALLERS_OF_FUNCTION: 查找函数调用点，需要 symbol
- PY_UPSTREAM_CALLGRAPH: 查找调用该函数的上游函数，需要 symbol
- PY_RETURN_VALUE_USAGE: 查找返回值使用情况，需要 symbol
- PY_EXCEPTION_HANDLING_AROUND_CALL: 查找未处理异常的调用，需要 symbol
- PY_REFERENCES_OF_SYMBOL: 查找符号引用，需要 symbol
- PY_FIELD_READ_WRITE_SITES: 查找字段读写位置，需要 field，mode 可选 (read/write/both)
- PY_ARGUMENT_SOURCES_AT_CALLSITE: 查找调用参数来源，需要 symbol

【Java 模板】
- JAVA_CALLERS_OF_METHOD: 查找方法调用点，需要 symbol
- JAVA_METHOD_OVERRIDE: 查找方法重写，需要 symbol
- JAVA_EXCEPTION_HANDLING: 查找未处理异常的调用，需要 symbol
- JAVA_FIELD_READ_WRITE: 查找字段读写位置，需要 field
- JAVA_ANNOTATION_USAGE: 查找注解使用，需要 symbol
- JAVA_ARGUMENT_SOURCES: 查找调用参数来源，需要 symbol

【Go 模板】
- GO_CALLERS_OF_FUNCTION: 查找函数调用点，需要 symbol
- GO_DEFER_USAGE: 查找 defer 使用情况，需要 symbol
- GO_ERROR_HANDLING: 查找错误处理情况，需要 symbol
- GO_GOROUTINE_SPAWN: 查找 goroutine 启动点，需要 symbol
- GO_INTERFACE_METHOD: 查找接口方法调用，需要 symbol
- GO_FIELD_READ_WRITE: 查找字段读写位置，需要 field

【C 模板】
- C_CALLERS_OF_FUNCTION: 查找函数调用点，需要 symbol
- C_POINTER_OPERATIONS: 查找指针操作，需要 symbol
- C_MEMORY_OPERATIONS: 查找内存操作(malloc/free)，需要 symbol
- C_BUFFER_OPERATIONS: 查找缓冲区操作，需要 symbol
- C_NULL_CHECK: 查找空指针检查，需要 symbol
- C_RETURN_VALUE: 查找返回值使用情况，需要 symbol

【Ruby 模板】
- RB_CALLERS_OF_METHOD: 查找方法调用点，需要 symbol
- RB_METHOD_MISSING: 查找 method_missing 定义（无需参数）
- RB_EVAL_USAGE: 查找 eval 使用（无需参数），或 send 调用需要 symbol
- RB_BLOCK_USAGE: 查找块使用，需要 symbol
- RB_EXCEPTION_HANDLING: 查找异常处理，需要 symbol
- RB_ATTR_ACCESS: 查找属性访问，需要 field

【TypeScript 模板】
- TS_CALLERS_OF_FUNCTION: 查找函数调用点，需要 symbol
- TS_PROMISE_USAGE: 查找 Promise/async 使用，需要 symbol
- TS_TYPE_ASSERTION: 查找类型断言（无需参数）
- TS_NULL_HANDLING: 查找空值处理，需要 symbol
- TS_DECORATOR_USAGE: 查找装饰器使用，需要 symbol
- TS_EXCEPTION_HANDLING: 查找异常处理，需要 symbol
- TS_FIELD_READ_WRITE: 查找字段读写位置，需要 field

输出 JSON schema：
{
  "planner": {
    "version": "1.0",
    "generated_at": "ISO8601",
    "notes": "string"
  },
  "features": [
    {
      "feature_name": "string",
      "feature_id": "string (optional)",
      "tasks": [
        {
          "template": "模板名称（如 PY_CALLERS_OF_FUNCTION 或 JAVA_CALLERS_OF_METHOD）",
          "language": "python|java|go|c|ruby|typescript",
          "params": {
            "symbol": "string (optional)",
            "field": "string (optional)",
            "mode": "read|write|both (optional)"
          },
          "priority": "high|medium|low",
          "reason": "string (facts only)",
          "scope": {
            "paths_hint": ["string"],
            "max_results": 200
          }
        }
      ]
    }
  ]
}

硬性规则：
- tasks 里每条必须包含 template、language、params、priority、reason
- template 必须来自上述允许列表
- 根据代码语言选择对应语言前缀的模板（如 Python 代码使用 PY_，Java 代码使用 JAVA_）
- 如果没有 symbol/field，就不要生成需要它的任务
- 每个 feature 最多 12 条任务（宁可少而精准）
"""


def _clean_json_text(text: str) -> str:
    t = (text or "").strip()
    if t.startswith("```"):
        # 去掉可能的 ```json ... ```
        t = t.replace("```json", "").replace("```", "").strip()
    # 尝试截取最外层 JSON
    if "{" in t:
        t = t[t.find("{"):]
    if "}" in t:
        t = t[: t.rfind("}") + 1]
    return t.strip()


def generate_feature_scan_tasks_and_update_plan(
    llm: ChatOpenAI,
    pr_dir: str,
    feature_risk_plan: Dict[str, Any],
    diff_ir: Dict[str, Any],
) -> Tuple[Dict[str, Any], Dict[str, int]]:
    """生成扫描任务并回写 feature_risk_plan.json

    Returns: (updated_feature_risk_plan, meta)
    """

    # 只把必要信息给 LLM，避免 token 爆炸
    slim_features: List[Dict[str, Any]] = []
    for idx, f in enumerate(feature_risk_plan.get("features", []) or []):
        hunks = f.get("hunks", []) or []
        # 限制每个 feature 的 hunk 样本量
        hunks_sample = []
        for h in hunks[:8]:
            hunks_sample.append(
                {
                    "hunk_id": h.get("hunk_id"),
                    "file_path": h.get("file_path"),
                    "language": h.get("language"),
                    "change_type": h.get("change_type"),
                    "risk_score": h.get("risk_score"),
                    "risk_summary": h.get("risk_summary"),
                }
            )

        slim_features.append(
            {
                "feature_name": f.get("feature_name") or f.get("name") or f"feature_{idx}",
                "risk_overview": f.get("risk_overview", {}),
                "why_focus": f.get("why_focus"),
                "hunks": hunks_sample,
            }
        )

    payload = {
        "repo": {"pr_dir": os.path.abspath(pr_dir)},
        "diff_summary": {
            "files_changed": len(diff_ir.get("files", []) or []),
        },
        "features": slim_features,
    }

    msgs = [
        SystemMessage(content=SYSTEM_PROMPT),
        HumanMessage(content=json.dumps(payload, ensure_ascii=False)),
    ]

    # Retry logic for LLM calls with null response handling
    max_retries = 3
    raw = None
    for attempt in range(max_retries):
        try:
            resp = llm.invoke(msgs)
            raw = resp.content if hasattr(resp, "content") else str(resp)
            if raw:
                break
        except TypeError as e:
            if "null value for `choices`" in str(e):
                import time
                time.sleep(1)
                continue
            raise
        except Exception:
            import time
            time.sleep(1)
            continue
    
    if not raw:
        # Fallback: return original plan without scan tasks, but mark as generated to prevent infinite loop
        fallback_plan = dict(feature_risk_plan)
        fallback_plan["scan_task_planner"] = {
            "generated": True,
            "version": "1.0",
            "generated_at": datetime.utcnow().isoformat() + "Z",
            "notes": "LLM fallback - no scan tasks generated due to API issues",
            "allowed_templates": ALLOWED_TEMPLATES,
        }
        # Write fallback plan to file
        out_dir = os.path.join(pr_dir, "out")
        os.makedirs(out_dir, exist_ok=True)
        out_path = os.path.join(out_dir, "feature_risk_plan.json")
        with open(out_path, "w", encoding="utf-8") as f:
            json.dump(fallback_plan, f, ensure_ascii=False, indent=2)
        return fallback_plan, {"features": len(fallback_plan.get("features", [])), "tasks": 0, "llm_status": "fallback"}
    
    cleaned = _clean_json_text(raw)
    planned = json.loads(cleaned)

    # 规范化与校验
    features_out: List[Dict[str, Any]] = planned.get("features", []) or []
    by_name = {f.get("feature_name"): f for f in features_out if f.get("feature_name")}

    updated_plan = dict(feature_risk_plan)
    updated_features = []
    tasks_total = 0

    for idx, f in enumerate(feature_risk_plan.get("features", []) or []):
        fname = f.get("feature_name") or f.get("name") or f"feature_{idx}"
        fcopy = dict(f)
        planned_f = by_name.get(fname)
        tasks = (planned_f or {}).get("tasks", []) or []

        # hard validate templates
        valid_tasks: List[Dict[str, Any]] = []
        for t in tasks:
            tpl = t.get("template")
            if tpl not in ALLOWED_TEMPLATES:
                continue
            params = t.get("params", {}) or {}
            
            # 需要 symbol 参数的模板
            templates_requiring_symbol = {
                # Python
                "PY_CALLERS_OF_FUNCTION",
                "PY_UPSTREAM_CALLGRAPH",
                "PY_RETURN_VALUE_USAGE",
                "PY_EXCEPTION_HANDLING_AROUND_CALL",
                "PY_REFERENCES_OF_SYMBOL",
                "PY_ARGUMENT_SOURCES_AT_CALLSITE",
                # Java
                "JAVA_CALLERS_OF_METHOD",
                "JAVA_METHOD_OVERRIDE",
                "JAVA_EXCEPTION_HANDLING",
                "JAVA_ANNOTATION_USAGE",
                "JAVA_ARGUMENT_SOURCES",
                # Go
                "GO_CALLERS_OF_FUNCTION",
                "GO_DEFER_USAGE",
                "GO_ERROR_HANDLING",
                "GO_GOROUTINE_SPAWN",
                "GO_INTERFACE_METHOD",
                # C
                "C_CALLERS_OF_FUNCTION",
                "C_POINTER_OPERATIONS",
                "C_MEMORY_OPERATIONS",
                "C_BUFFER_OPERATIONS",
                "C_NULL_CHECK",
                "C_RETURN_VALUE",
                # Ruby
                "RB_CALLERS_OF_METHOD",
                "RB_EVAL_USAGE",
                "RB_BLOCK_USAGE",
                "RB_EXCEPTION_HANDLING",
                # TypeScript
                "TS_CALLERS_OF_FUNCTION",
                "TS_PROMISE_USAGE",
                "TS_NULL_HANDLING",
                "TS_DECORATOR_USAGE",
                "TS_EXCEPTION_HANDLING",
            }
            
            # 需要 field 参数的模板
            templates_requiring_field = {
                "PY_FIELD_READ_WRITE_SITES",
                "JAVA_FIELD_READ_WRITE",
                "GO_FIELD_READ_WRITE",
                "RB_ATTR_ACCESS",
                "TS_FIELD_READ_WRITE",
            }
            
            # 不需要参数的模板
            templates_no_params = {
                "RB_METHOD_MISSING",
                "TS_TYPE_ASSERTION",
            }
            
            # 验证参数
            if tpl in templates_requiring_symbol:
                if not (params.get("symbol") or "").strip():
                    continue
            elif tpl in templates_requiring_field:
                if not (params.get("field") or "").strip():
                    continue
            # templates_no_params 不需要检查

            valid_tasks.append(t)

        # 限制数量
        valid_tasks = valid_tasks[:12]
        tasks_total += len(valid_tasks)

        fcopy["scan_tasks"] = valid_tasks
        updated_features.append(fcopy)

    updated_plan["features"] = updated_features
    updated_plan["scan_task_planner"] = {
        "generated": True,
        "version": planned.get("planner", {}).get("version", "1.0"),
        "generated_at": planned.get("planner", {}).get("generated_at") or datetime.utcnow().isoformat() + "Z",
        "notes": planned.get("planner", {}).get("notes", ""),
        "allowed_templates": ALLOWED_TEMPLATES,
    }

    # 回写到 out/feature_risk_plan.json
    out_dir = os.path.join(pr_dir, "out")
    os.makedirs(out_dir, exist_ok=True)
    out_path = os.path.join(out_dir, "feature_risk_plan.json")
    with open(out_path, "w", encoding="utf-8") as f:
        json.dump(updated_plan, f, ensure_ascii=False, indent=2)

    meta = {"features": len(updated_features), "tasks": tasks_total}
    return updated_plan, meta
