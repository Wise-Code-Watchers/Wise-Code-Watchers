"""
TODO List生成器 - 基于feature_risk_plan生成代码审计任务列表
"""

import json
import os
from typing import Any, Dict, List, Optional
from langchain_core.messages import SystemMessage, HumanMessage
from langchain_openai import ChatOpenAI

from ..core.code_tools import create_code_tools_for_workflow


def generate_audit_todolist_prompt(feature_risk_plan: Dict[str, Any],
                                 diff_ir: Dict[str, Any]) -> str:
    """生成TODO List的LLM提示词"""

    features = feature_risk_plan.get("features", [])
    top_focus = feature_risk_plan.get("top_focus", [])

    # 提取已确认风险的功能（基于verified_risk）
    confirmed_features = []
    for feature in features:
        hunks = feature.get("hunks", [])
        confirmed_hunks = [
            h for h in hunks
            if (h.get("verified_risk") or {}).get("risk_type") and (h.get("verified_risk") or {}).get("risk_type") != "NONE"
        ]
        if not confirmed_hunks:
            continue

        confirmed_features.append({
            "feature_id": feature.get("feature_id"),
            "feature_name": feature.get("feature_name"),
            "risk_score": feature.get("risk_overview", {}).get("max_risk_score", 0),
            "confirmed_hunks": [
                {
                    "hunk_id": h.get("hunk_id"),
                    "file_path": h.get("file_path"),
                    "risk_type": (h.get("verified_risk") or {}).get("risk_type"),
                    "confidence": (h.get("verified_risk") or {}).get("confidence"),
                    "evidence": (h.get("verified_risk") or {}).get("evidence", []),
                    "why": (h.get("verified_risk") or {}).get("why", ""),
                    "hunk_text": h.get("hunk_text", "")
                }
                for h in confirmed_hunks
            ]
        })

    # 如果没有确认的风险，返回空的prompt但格式正确
    if not confirmed_features:
        return """你是一个资深的代码安全审计专家。当前PR中没有已确认的安全风险需要审计。

请按照以下JSON格式输出空任务列表：

{
  "audit_summary": {
    "total_high_risk_features": 0,
    "total_audit_tasks": 0,
    "estimated_audit_hours": 0,
    "critical_issues_count": 0
  },
  "audit_tasks": [],
  "execution_plan": {
    "phase_1": [],
    "phase_2": [],
    "parallel_tasks": []
  }
}

由于没有confirmed_hunks，请不要生成任何审计任务。"""

    prompt = f"""你是一个资深的代码安全审计专家。请基于以下已确认的安全风险，制定详细的代码审计TODO列表。

## 已确认安全风险功能（仅对这些生成审计任务）:

{json.dumps(confirmed_features, ensure_ascii=False, indent=2)}

## 审计要求:

请为每个已确认风险功能制定具体的审计任务，每个任务必须包含：

1. **明确的审计目标** - 针对已确认的风险类型进行检查
2. **具体的审计方法** - 如何进行检查（函数调用分析、数据流追踪、权限检查等）
3. **相关文件和代码位置** - 需要检查的文件路径和代码区域
4. **风险类型分类** - 与confirmed_hunks中的risk_type一致
5. **优先级** - High/Medium/Low
6. **依赖关系** - 任务之间的依赖
7. **证据绑定** - 必须引用confirmed_hunks中的evidence

## 特别关注的安全问题类型:
- **权限控制** - 访问权限检查、认证绕过
- **输入验证** - 参数校验、注入防护
- **数据处理** - 敏感数据处理、数据泄露风险
- **并发安全** - 竞态条件、死锁、数据一致性
- **错误处理** - 异常处理、错误信息泄露
- **业务逻辑** - 状态管理、流程控制漏洞

## 输出格式要求:

请严格按照以下JSON格式输出TODO列表：

{{
  "audit_summary": {{
    "total_high_risk_features": 0,
    "total_audit_tasks": 0,
    "estimated_audit_hours": 0,
    "critical_issues_count": 0
  }},
  "audit_tasks": [
    {{
      "task_id": "task_001",
      "feature_id": "feature_id",
      "feature_name": "功能名称",
      "task_title": "任务标题",
      "description": "详细描述",
      "audit_objective": "审计目标",
      "audit_method": "审计方法",
      "target_files": ["file1.py", "file2.py"],
      "target_functions": ["func1", "func2"],
      "risk_categories": ["security", "logic"],
      "priority": "High|Medium|Low",
      "estimated_hours": 2,
      "dependencies": ["task_000"],
      "check_points": [
        "检查点1: 具体要检查的内容",
        "检查点2: 具体要检查的内容"
      ],
      "evidence_hunks": ["hunk_id_1", "hunk_id_2"],
      "expected_findings": "预期发现的问题类型"
    }}
  ],
  "execution_plan": {{
    "phase_1": ["task_001", "task_002"],
    "phase_2": ["task_003", "task_004"],
    "parallel_tasks": [["task_005", "task_006"], ["task_007", "task_008"]]
  }}
}}

## 重要硬规则（违反即视为无效任务）:
- 只允许针对 confirmed_hunks 生成任务；如果某个风险点 risk_type 为 NONE，严禁生成任务。
- 每个任务必须包含 evidence_hunks 字段（数组），其中每个元素必须是输入中出现过的 hunk_id。
- 任务的 check_points 必须引用 evidence 中出现的关键词/调用/变量（能对得上）。
- 如果无法写出证据链，请不要输出该任务。
- 没有confirmed_hunks的feature不许出任务
"""

    return prompt


def generate_audit_todolist(
    feature_risk_plan: Dict[str, Any],
    diff_ir: Dict[str, Any],
    llm: ChatOpenAI
) -> Dict[str, Any]:
    """
    生成代码审计TODO列表

    Args:
        feature_risk_plan: 功能风险分析结果
        diff_ir: 差异信息
        llm: 语言模型

    Returns:
        TODO列表结果
    """
    prompt = generate_audit_todolist_prompt(feature_risk_plan, diff_ir)

    messages = [
        SystemMessage(content="你是一个资深的代码安全审计专家，擅长制定系统化的代码审计计划。"),
        HumanMessage(content=prompt)
    ]

    try:
        response = llm.invoke(messages)
        response_text = response.content if hasattr(response, "content") else str(response)

        # 解析JSON响应
        try:
            # 清理响应文本，提取JSON
            json_start = response_text.find("{")
            json_end = response_text.rfind("}") + 1
            if json_start != -1 and json_end > json_start:
                json_text = response_text[json_start:json_end]
                todolist = json.loads(json_text)
            else:
                todolist = json.loads(response_text)
        except json.JSONDecodeError as e:
            # 如果JSON解析失败，返回基本结构
            return {
                "success": False,
                "error": f"JSON解析失败: {str(e)}",
                "raw_response": response_text[:1000],
                "audit_tasks": []
            }

        # 验证和修复TODO列表结构
        todolist = validate_and_fix_todolist(todolist, feature_risk_plan)

        return {
            "success": True,
            "todolist": todolist,
            "total_tasks": len(todolist.get("audit_tasks", [])),
            "high_risk_tasks": len([t for t in todolist.get("audit_tasks", [])
                                   if t.get("priority") == "High"])
        }

    except Exception as e:
        return {
            "success": False,
            "error": f"生成TODO列表失败: {str(e)}",
            "audit_tasks": []
        }


def validate_and_fix_todolist(todolist: Dict[str, Any],
                             feature_risk_plan: Dict[str, Any]) -> Dict[str, Any]:
    """验证和修复TODO列表结构"""

    # 确保基本结构存在
    if "audit_tasks" not in todolist:
        todolist["audit_tasks"] = []

    if "audit_summary" not in todolist:
        todolist["audit_summary"] = {
            "total_high_risk_features": 0,
            "total_audit_tasks": 0,
            "estimated_audit_hours": 0,
            "critical_issues_count": 0
        }

    if "execution_plan" not in todolist:
        todolist["execution_plan"] = {
            "phase_1": [],
            "phase_2": [],
            "parallel_tasks": []
        }

    # 为每个任务添加缺失的字段
    for i, task in enumerate(todolist["audit_tasks"]):
        if "task_id" not in task:
            task["task_id"] = f"task_{i+1:03d}"

        if "priority" not in task:
            task["priority"] = "Medium"

        if "estimated_hours" not in task:
            task["estimated_hours"] = 1

        if "dependencies" not in task:
            task["dependencies"] = []

        if "check_points" not in task:
            task["check_points"] = []

        if "target_files" not in task:
            task["target_files"] = []

        if "target_functions" not in task:
            task["target_functions"] = []

        if "risk_categories" not in task:
            task["risk_categories"] = []

    # 更新汇总信息
    todolist["audit_summary"]["total_audit_tasks"] = len(todolist["audit_tasks"])
    todolist["audit_summary"]["total_high_risk_features"] = len(
        [f for f in feature_risk_plan.get("features", [])
         if f.get("risk_overview", {}).get("max_risk_score", 0) >= 70]
    )
    todolist["audit_summary"]["estimated_audit_hours"] = sum(
        task.get("estimated_hours", 1) for task in todolist["audit_tasks"]
    )

    # 生成执行计划
    high_priority_tasks = [t["task_id"] for t in todolist["audit_tasks"]
                          if t.get("priority") == "High"]
    medium_priority_tasks = [t["task_id"] for t in todolist["audit_tasks"]
                            if t.get("priority") == "Medium"]
    low_priority_tasks = [t["task_id"] for t in todolist["audit_tasks"]
                         if t.get("priority") == "Low"]

    todolist["execution_plan"]["phase_1"] = high_priority_tasks[:3]
    todolist["execution_plan"]["phase_2"] = high_priority_tasks[3:] + medium_priority_tasks[:3]

    # 并行任务
    if len(medium_priority_tasks) > 3:
        todolist["execution_plan"]["parallel_tasks"] = [
            medium_priority_tasks[3:5],
            medium_priority_tasks[5:7] + low_priority_tasks[:2]
        ]

    return todolist


def generate_audit_todolist_for_findings(
    verified_findings: List[Dict[str, Any]],
    suspicions: List[Dict[str, Any]],
    diff_ir: Dict[str, Any],
    llm: ChatOpenAI
) -> Dict[str, Any]:
    """
    基于已确认发现生成审计TODO列表 - 最低误报优先

    Args:
        verified_findings: 已确认的漏洞发现
        suspicions: 疑点（不算漏洞）
        diff_ir: 差异信息
        llm: 语言模型

    Returns:
        TODO列表结果
    """
    if not verified_findings:
        # 没有确认发现，返回空任务列表
        return {
            "success": True,
            "todolist": {
                "audit_summary": {
                    "total_confirmed_findings": 0,
                    "total_audit_tasks": 0,
                    "estimated_audit_hours": 0,
                    "critical_issues_count": 0
                },
                "audit_tasks": [],
                "execution_plan": {
                    "phase_1": [],
                    "phase_2": [],
                    "parallel_tasks": []
                },
                "suspicions_summary": {
                    "total_suspicions": len(suspicions),
                    "suspicions": suspicions
                }
            },
            "total_tasks": 0,
            "high_risk_tasks": 0
        }

    # 构建prompt，强制evidence_refs绑定
    prompt = f"""你是资深的代码安全审计专家。请基于以下已确认的安全漏洞发现，制定详细的代码审计TODO列表。

## 已确认漏洞发现（CONFIRMED）:

{json.dumps(verified_findings, ensure_ascii=False, indent=2)}

## 疑点列表（SUSPECTED - 仅供参考，不生成任务）:

{json.dumps(suspicions, ensure_ascii=False, indent=2)}

## 审计要求（硬约束）：

请为每个CONFIRMED漏洞制定具体的审计任务：

1. **证据绑定** - 每个任务必须包含evidence_refs字段，引用verified_findings中的ID或证据
2. **精确路径** - 必须包含具体的file_path和line_numbers
3. **验证目标** - 针对已确认的漏洞类型进行深度验证
4. **限制任务数** - 每个CONFIRMED finding最多生成1-2个任务
5. **强制字段** - 必须包含semgrep_finding或attack_path的引用

## 重要硬规则（违反即视为无效任务）：
- 只允许针对verified_findings生成任务
- 每个任务必须包含evidence_refs数组，引用finding的ID
- 任务的target_files和line_numbers必须与finding对应
- 如果无法建立证据链，请不要输出该任务
- 总任务数不能超过{len(verified_findings) * 2}个

## JSON输出格式：

{{
  "audit_summary": {{
    "total_confirmed_findings": {len(verified_findings)},
    "total_audit_tasks": 0,
    "estimated_audit_hours": 0,
    "critical_issues_count": 0
  }},
  "audit_tasks": [
    {{
      "task_id": "task_001",
      "finding_id": "finding_id",
      "risk_type": "SQL_INJECTION|COMMAND_INJECTION|...",
      "task_title": "任务标题",
      "description": "详细描述",
      "audit_objective": "验证目标",
      "target_files": ["file1.py"],
      "target_lines": [123, 124],
      "evidence_refs": ["finding_id", "semgrep_rule_id"],
      "semgrep_finding": {{}},
      "risk_categories": ["security"],
      "priority": "High|Medium|Low",
      "estimated_hours": 2,
      "attack_path": "攻击路径描述"
    }}
  ],
  "execution_plan": {{
    "phase_1": ["task_001"],
    "phase_2": ["task_002"],
    "parallel_tasks": [["task_003", "task_004"]]
  }}
}}

请严格按照上述JSON格式输出，确保证据链完整性。"""

    messages = [
        SystemMessage(content="你是一个资深的代码安全审计专家，擅长基于已确认发现制定精确的审计任务。"),
        HumanMessage(content=prompt)
    ]

    try:
        response = llm.invoke(messages)
        response_text = response.content if hasattr(response, 'content') else str(response)

        # 解析JSON响应
        try:
            json_start = response_text.find("{")
            json_end = response_text.rfind("}") + 1
            if json_start != -1 and json_end > json_start:
                json_text = response_text[json_start:json_end]
                todolist = json.loads(json_text)
            else:
                todolist = json.loads(response_text)
        except json.JSONDecodeError as e:
            return {
                "success": False,
                "error": f"JSON解析失败: {str(e)}",
                "raw_response": response_text[:1000],
                "audit_tasks": []
            }

        # 验证和修复TODO列表结构
        todolist = validate_and_fix_todolist_for_findings(todolist, verified_findings, suspicions)

        return {
            "success": True,
            "todolist": todolist,
            "total_tasks": len(todolist.get("audit_tasks", [])),
            "high_risk_tasks": len([t for t in todolist.get("audit_tasks", []) if t.get("priority") == "High"])
        }

    except Exception as e:
        return {
            "success": False,
            "error": f"生成TODO列表失败: {str(e)}",
            "audit_tasks": []
        }


def validate_and_fix_todolist_for_findings(todolist: Dict[str, Any],
                                         verified_findings: List[Dict[str, Any]],
                                         suspicions: List[Dict[str, Any]]) -> Dict[str, Any]:
    """验证和修复基于findings的TODO列表结构"""

    # 确保基本结构存在
    if "audit_tasks" not in todolist:
        todolist["audit_tasks"] = []

    if "audit_summary" not in todolist:
        todolist["audit_summary"] = {
            "total_confirmed_findings": len(verified_findings),
            "total_audit_tasks": 0,
            "estimated_audit_hours": 0,
            "critical_issues_count": 0
        }

    if "execution_plan" not in todolist:
        todolist["execution_plan"] = {
            "phase_1": [],
            "phase_2": [],
            "parallel_tasks": []
        }

    # 添加疑点摘要
    todolist["suspicions_summary"] = {
        "total_suspicions": len(suspicions),
        "suspicions": suspicions
    }

    # 为每个任务添加缺失的字段
    for i, task in enumerate(todolist["audit_tasks"]):
        if "task_id" not in task:
            task["task_id"] = f"task_{i+1:03d}"

        if "priority" not in task:
            task["priority"] = "Medium"

        if "estimated_hours" not in task:
            task["estimated_hours"] = 2

        if "evidence_refs" not in task:
            task["evidence_refs"] = []

        if "target_files" not in task:
            task["target_files"] = []

        if "target_lines" not in task:
            task["target_lines"] = []

        if "risk_categories" not in task:
            task["risk_categories"] = ["security"]

    # 更新汇总信息
    todolist["audit_summary"]["total_confirmed_findings"] = len(verified_findings)
    todolist["audit_summary"]["total_audit_tasks"] = len(todolist["audit_tasks"])
    todolist["audit_summary"]["critical_issues_count"] = len([
        f for f in verified_findings if f.get("severity") == "CRITICAL"
    ])
    todolist["audit_summary"]["estimated_audit_hours"] = sum(
        task.get("estimated_hours", 2) for task in todolist["audit_tasks"]
    )

    return todolist


def create_code_tools_for_pr(
    pr_dir: str,
    feature_risk_plan: Dict[str, Any],
    codebase_path: Optional[str] = None
) -> Dict[str, Any]:
    """
    为PR创建代码工具并预加载相关文件信息

    Args:
        pr_dir: PR目录
        feature_risk_plan: 功能风险分析结果
        codebase_path: 克隆的源代码路径（优先使用）

    Returns:
        代码工具和预加载信息
    """
    # 加载PR metadata以获取base_branch信息
    metadata_path = os.path.join(pr_dir, "metadata.json")
    metadata = None
    if os.path.exists(metadata_path):
        with open(metadata_path, "r", encoding="utf-8") as f:
            metadata = json.load(f)

    code_tools = create_code_tools_for_workflow(pr_dir, metadata, codebase_path)

    # 预加载高风险功能的文件信息
    high_risk_files = set()
    high_risk_functions = set()

    for feature in feature_risk_plan.get("features", []):
        risk_score = feature.get("risk_overview", {}).get("max_risk_score", 0)
        if risk_score >= 70:  # 高风险
            for hunk in feature.get("hunks", []):
                file_path = hunk.get("file_path")
                if file_path:
                    high_risk_files.add(file_path)

    # 文件结构信息
    file_structures = {}
    for file_path in list(high_risk_files)[:10]:  # 限制预加载数量
        structure = code_tools.get_file_structure(
            os.path.dirname(file_path), max_depth=2
        )
        if structure["success"]:
            file_structures[file_path] = structure

    return {
        "code_tools": code_tools,
        "high_risk_files": list(high_risk_files),
        "high_risk_functions": list(high_risk_functions),
        "file_structures": file_structures,
        "tools_summary": {
            "base_directories": [str(p) for p in code_tools.base_dirs],
            "high_risk_files_count": len(high_risk_files),
            "preloaded_structures_count": len(file_structures)
        }
    }