"""
Initialization Engine (Patch版) - 初始化阶段核心逻辑
目标：控输入、立边界、降误报

特点：
- 先硬过滤（规则）
- 再 LLM 门控（JSON-only）
- LLM 失败则规则兜底（避免全 skip / 不稳定）
- required_context 受控枚举，并与 get_context_for_unit 对齐
"""

from __future__ import annotations

import json
import time
import re
from typing import List, Dict, Any, Tuple, Optional
import logging

from langchain_openai import ChatOpenAI

from ..core.types import AuditUnit, InitializationResult, InitializationDecision
from langchain_core.messages import SystemMessage, HumanMessage

from ..parsing.diff_slicer import DiffSlicer
from ..core.context_builder import ContextBuilder

# 配置日志 - 避免重复handler
logger = logging.getLogger(__name__)
if not logger.handlers:
    handler = logging.StreamHandler()
    handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)
    logger.propagate = False


# -----------------------------
# 小工具：diff/注释/格式判断
# -----------------------------

_DIFF_PREFIX_RE = re.compile(r"^\s*([+-])\s?")


def _strip_diff_prefix(line: str) -> str:
    """去掉 diff 前缀 +/-, 保留内容"""
    m = _DIFF_PREFIX_RE.match(line)
    if m:
        return line[m.end():]
    return line


def _is_blank_or_comment(line: str) -> bool:
    """
    初始化阶段的轻量注释/空行识别（多语言通用）
    注意：这里不追求100%正确，只求有效过滤明显无意义的diff。
    """
    t = _strip_diff_prefix(line).strip()
    if not t:
        return True

    # 单行注释
    if t.startswith(("//", "#", "--")):
        return True

    # 块注释常见片段
    if t.startswith(("/*", "*")) or t.endswith("*/"):
        return True

    return False


def _looks_like_format_only(diff_hunk: str) -> bool:
    """
    判断是否“近似仅格式化”：
    - 只改空白
    - 或只改括号换行之类
    这里用启发式：对每行去掉 diff 前缀后再去掉所有空白字符，比较变化是否“近似无实质字符变化”。
    """
    lines = [ln for ln in diff_hunk.splitlines() if ln.strip()]
    if not lines:
        return True

    added = []
    removed = []
    for ln in lines:
        s = ln.lstrip()
        if s.startswith("+"):
            added.append(_strip_diff_prefix(ln))
        elif s.startswith("-"):
            removed.append(_strip_diff_prefix(ln))

    if not added and not removed:
        return False

    def norm(x: str) -> str:
        # 去掉所有空白
        return re.sub(r"\s+", "", x)

    # 若新增/删除在“去空白后”完全一致，基本就是格式化/换行
    if len(added) == len(removed) and all(norm(a) == norm(r) for a, r in zip(added, removed)):
        return True

    return False


def _is_config_like(language: str, file_path: str) -> bool:
    fp = (file_path or "").lower()
    lang = (language or "").lower()
    return (
        lang in {"yaml", "yml", "toml", "json", "ini", "dockerfile", "bash", "sh"} or
        fp.endswith((".yaml", ".yml", ".toml", ".json", ".ini", ".env", "dockerfile", ".sh"))
    )


def _impact_any_true(impact: Dict[str, Any]) -> bool:
    keys = [
        "control_flow", "data_flow", "security_surface", "model_prompt",
        "file_system", "network_io", "database_access"
    ]
    return any(bool(impact.get(k, False)) for k in keys)


# -----------------------------
# Engine
# -----------------------------

class InitializationEngine:
    """初始化引擎 - 控输入、立边界、降误报（Patch版）"""

    # 受控 required_context 枚举（只允许这几个，且 get_context_for_unit 已覆盖）
    ALLOWED_CONTEXT = {"symbol", "config", "call_graph"}

    def __init__(self, llm: ChatOpenAI):
        self.llm = llm
        self.diff_slicer = DiffSlicer()
        self.context_builder = ContextBuilder()

        # JSON-only 的 system prompt（强约束，减少解析失败）
        self.system_prompt = """你是 AI Code Review 系统的【初始化门控 Agent】。目标：控输入、立边界、降误报。

你只做门控，不做缺陷判断：
- 不允许判断“是否存在漏洞/逻辑错误”
- 不允许给改进建议
- 不允许使用“可能/潜在/建议关注”等推测

你的任务：对每个审计单元输出门控决策：
- decision: "pass" 或 "skip"
- reason: 仅陈述可从 diff_hunk 与 impact 字段直接得到的事实（不要推测）
- required_context: 后续判定所需的最小上下文集合（只允许：symbol/config/call_graph）
- confidence: 0-1，仅表示“门控判断是否基于足够信息”（不是缺陷置信度）

门控规则：
- 直接 SKIP：
  - is_test_code=true 或 is_generated=true
  - diff_hunk 仅包含注释/空行/格式化
- 直接 PASS：
  - impact 中任一为 true（control_flow/data_flow/security_surface/model_prompt/file_system/network_io/database_access）
- 若 impact 全为 false：SKIP，并在 reason 说明 impact 全 false

required_context 选择规则（只选必要的）：
- 若 symbol.name 存在 且 (control_flow 或 data_flow 或 security_surface) → 至少包含 "symbol"
- 若 symbol.name 存在 且 (control_flow 或 data_flow 或 security_surface) → 可再包含 "call_graph"
- 若 file_path/语言看起来是配置类文件 或 impact 涉及 file_system → 可包含 "config"
- 若 symbol.name 不存在：不要返回 "symbol" 或 "call_graph"

输出必须是严格 JSON（不要代码块、不要多余文字）。"""

        self.user_prompt_template = """审计单元（AuditUnit）如下：
{audit_unit_json}
请按规则输出严格 JSON。"""

    # -------------------------
    # 规则硬过滤
    # -------------------------

    def hard_filter(self, units: List[AuditUnit]) -> Tuple[List[AuditUnit], Dict[str, int]]:
        """
        硬过滤器 - 预过滤明显无意义单元
        Returns: (filtered_units, skip_reasons_count)
        """
        logger.info(f"[硬过滤器] 开始处理 {len(units)} 个单元")
        filtered: List[AuditUnit] = []
        reasons_count: Dict[str, int] = {}

        for i, unit in enumerate(units):
            reasons: List[str] = []

            file_path = unit.get("file_path", "")
            language = unit.get("language", "")
            diff_hunk = (unit.get("diff_hunk", "") or "").strip()
            symbol_name = unit.get("symbol", {}).get("name", "")

            logger.info(f"[硬过滤器] 处理单元 {i+1}/{len(units)}: {file_path} (symbol: {symbol_name})")

            if unit.get("is_generated", False):
                reasons.append("generated")
                logger.info(f"[硬过滤器] 检测到生成代码: {file_path}")

            if unit.get("is_test_code", False):
                reasons.append("test_code")
                logger.info(f"[硬过滤器] 检测到测试代码: {file_path}")

            if not diff_hunk:
                reasons.append("empty_diff")
                logger.info(f"[硬过滤器] 检测到空diff: {file_path}")
            else:
                # comments only
                lines = diff_hunk.splitlines()
                non_trivial = [ln for ln in lines if not _is_blank_or_comment(ln)]
                if not non_trivial:
                    reasons.append("comments_only")
                    logger.info(f"[硬过滤器] 检测到纯注释: {file_path}")

                # format-only（启发式）
                if _looks_like_format_only(diff_hunk):
                    reasons.append("format_only")
                    logger.info(f"[硬过滤器] 检测到格式化变更: {file_path}")

            # 检查impact，如果有任何impact，即使无symbol也要让LLM决定
            impact = unit.get("impact", {}) or {}
            has_any_impact = _impact_any_true(impact)

            # symbol 缺失不再一刀切：仅对无impact且非config-like的普通代码才强要求
            symbol = unit.get("symbol", {}) or {}
            symbol_name = (symbol.get("name") or "").strip()
            if not symbol_name and not has_any_impact and not _is_config_like(language, file_path):
                # 普通代码没有symbol且无impact：大概率是噪声
                reasons.append("no_symbol_no_impact")
                logger.info(f"[硬过滤器] 非配置文件缺少符号: {file_path} (lang: {language})")

            if reasons:
                logger.info(f"[硬过滤器] 跳过单元: {file_path}, 原因: {reasons}")
                for r in reasons:
                    reasons_count[r] = reasons_count.get(r, 0) + 1
                continue

            logger.info(f"[硬过滤器] 通过单元: {file_path}")
            filtered.append(unit)

        logger.info(f"[硬过滤器] 完成处理: {len(filtered)}/{len(units)} 单元通过")
        return filtered, reasons_count

    # -------------------------
    # 规则兜底决策（LLM失败时使用）
    # -------------------------

    def _fallback_decision(self, unit: AuditUnit) -> InitializationDecision:
        file_path = unit.get("file_path", "")
        language = unit.get("language", "")
        impact = unit.get("impact", {}) or {}
        symbol = unit.get("symbol", {}) or {}
        symbol_name = (symbol.get("name") or "").strip()

        logger.info(f"[规则兜底] 开始处理单元: {file_path}")

        if unit.get("is_test_code", False) or unit.get("is_generated", False):
            logger.info(f"[规则兜底] 跳过: test/generated - {file_path}")
            return {"decision": "skip", "reason": "rule: test/generated", "required_context": [], "confidence": 0.25}

        diff_hunk = (unit.get("diff_hunk", "") or "").strip()
        if not diff_hunk:
            logger.info(f"[规则兜底] 跳过: empty diff - {file_path}")
            return {"decision": "skip", "reason": "rule: empty diff", "required_context": [], "confidence": 0.3}

        lines = diff_hunk.splitlines()
        non_trivial = [ln for ln in lines if not _is_blank_or_comment(ln)]
        if not non_trivial:
            logger.info(f"[规则兜底] 跳过: comments/blank only - {file_path}")
            return {"decision": "skip", "reason": "rule: comments/blank only", "required_context": [], "confidence": 0.35}

        if _looks_like_format_only(diff_hunk):
            logger.info(f"[规则兜底] 跳过: format-only change - {file_path}")
            return {"decision": "skip", "reason": "rule: format-only change", "required_context": [], "confidence": 0.35}

        any_impact = _impact_any_true(impact)
        if not any_impact:
            logger.info(f"[规则兜底] 跳过: impact all false - {file_path}")
            return {"decision": "skip", "reason": "rule: impact all false", "required_context": [], "confidence": 0.45}

        # PASS：impact 命中
        required: List[str] = []
        if symbol_name:
            required.append("symbol")
            # 只有当需要理解调用关系时才加 call_graph（这里用启发式：control/data/security 任一）
            if any(bool(impact.get(k, False)) for k in ["control_flow", "data_flow", "security_surface"]):
                required.append("call_graph")

        if _is_config_like(language, file_path) or bool(impact.get("file_system", False)):
            required.append("config")

        # 去重 & 保序
        seen = set()
        required = [x for x in required if not (x in seen or seen.add(x))]
        required = [x for x in required if x in self.ALLOWED_CONTEXT]

        logger.info(f"[规则兜底] 通过: {file_path}, required_context: {required}")
        return {
            "decision": "pass",
            "reason": "rule: impact hit",
            "required_context": required,
            "confidence": 0.55
        }

    # -------------------------
    # LLM 决策
    # -------------------------

    def make_initialization_decision(self, unit: AuditUnit) -> InitializationDecision:
        """
        对单个审计单元做初始化门控决策
        - LLM 输出 JSON-only
        - 解析失败 fallback 到规则决策
        """
        file_path = unit.get("file_path", "")
        logger.info(f"[LLM决策] 开始处理单元: {file_path}")

        try:
            user_prompt = self.user_prompt_template.format(
                audit_unit_json=json.dumps(unit, ensure_ascii=False)
            )

            logger.info(f"[LLM决策] 构建提示完成，准备调用LLM: {file_path}")

            messages = [
                SystemMessage(content=self.system_prompt),
                HumanMessage(content=user_prompt)
            ]

            logger.info(f"[LLM决策] 调用LLM API: {file_path}")
            response = self.llm.invoke(messages)
            text = (response.content or "").strip()

            logger.info(f"[LLM决策] LLM响应: {file_path}")
            logger.info(f"[LLM决策] 响应内容: {text[:200]}...")  # 只显示前200字符

            # 强制 JSON-only：取第一个 { 到最后一个 }
            try:
                if "{" not in text or "}" not in text:
                    logger.warning(f"[LLM决策] 响应中无JSON对象: {file_path}")
                    raise ValueError("no_json_object")

                json_text = text[text.find("{"): text.rfind("}") + 1]
                logger.info(f"[LLM决策] 提取的JSON: {json_text}")
                data = json.loads(json_text)

                decision = str(data.get("decision", "")).lower().strip()
                if decision not in ("pass", "skip"):
                    logger.warning(f"[LLM决策] 无效决策 '{decision}'，默认skip: {file_path}")
                    decision = "skip"

                reason = str(data.get("reason", "")).strip() or "llm: no reason"
                confidence = float(data.get("confidence", 0.5))
                confidence = max(0.0, min(1.0, confidence))

                required_context = data.get("required_context", [])
                if not isinstance(required_context, list):
                    logger.warning(f"[LLM决策] required_context不是列表: {file_path}")
                    required_context = []

                # required_context 受控枚举 + 去重保序
                seen = set()
                normalized: List[str] = []
                for x in required_context:
                    sx = str(x).strip()
                    if sx in self.ALLOWED_CONTEXT and sx not in seen:
                        seen.add(sx)
                        normalized.append(sx)

                # 若 unit 没有 symbol.name，则不允许 symbol/call_graph
                symbol = unit.get("symbol", {}) or {}
                symbol_name = (symbol.get("name") or "").strip()
                if not symbol_name:
                    normalized = [x for x in normalized if x not in ("symbol", "call_graph")]

                result = {
                    "decision": decision,
                    "reason": reason,
                    "required_context": normalized,
                    "confidence": confidence
                }

                logger.info(f"[LLM决策] LLM决策成功: {file_path} -> {decision} (confidence: {confidence}, context: {normalized})")
                return result

            except Exception as parse_e:
                logger.error(f"[LLM决策] JSON解析失败: {file_path}, 错误: {str(parse_e)}")
                fb = self._fallback_decision(unit)
                fb["reason"] = f"{fb.get('reason','rule')}; llm_parse_fail: {str(parse_e)}"
                fb["confidence"] = float(fb.get("confidence", 0.4))
                return fb

        except Exception as e:
            logger.error(f"[LLM决策] LLM调用失败: {file_path}, 错误: {str(e)}")
            fb = self._fallback_decision(unit)
            fb["reason"] = f"{fb.get('reason','rule')}; llm_error: {str(e)}"
            fb["confidence"] = float(fb.get("confidence", 0.35))
            return fb

    # -------------------------
    # 完整初始化流程
    # -------------------------

    def initialize_audit_units(self, diff_content: str, pr_dir: str) -> InitializationResult:
        start = time.time()
        logger.info(f"[初始化引擎] 开始初始化流程，PR目录: {pr_dir}")

        try:
            # 1) diff 切片
            logger.info(f"[初始化引擎] 步骤1: diff切片")
            raw_units = self.diff_slicer.slice_diff(diff_content)
            logger.info(f"[初始化引擎] diff切片完成，获得 {len(raw_units)} 个原始单元")

            if not raw_units:
                logger.warning(f"[初始化引擎] 没有获取到审计单元，返回空结果")
                return {
                    "success": True,
                    "audit_units": [],
                    "total_units": 0,
                    "passed_units": 0,
                    "skipped_units": 0,
                    "skipped_reasons": {"no_units": 1},
                    "processing_time": time.time() - start,
                }

            # 2) 硬过滤
            logger.info(f"[初始化引擎] 步骤2: 硬过滤器预筛选")
            filtered_units, hard_skips = self.hard_filter(raw_units)
            logger.info(f"[初始化引擎] 硬过滤完成: {len(filtered_units)}/{len(raw_units)} 单元通过，跳过原因: {hard_skips}")

            # 3) LLM 门控
            logger.info(f"[初始化引擎] 步骤3: LLM门控决策")
            final_units: List[AuditUnit] = []
            llm_skips: Dict[str, int] = {}

            for i, unit in enumerate(filtered_units):
                file_path = unit.get("file_path", "")
                logger.info(f"[初始化引擎] LLM处理单元 {i+1}/{len(filtered_units)}: {file_path}")

                decision = self.make_initialization_decision(unit)

                if decision.get("decision") == "pass":
                    logger.info(f"[初始化引擎] 单元通过LLM决策: {file_path}")
                    unit["initialization_decision"] = decision
                    unit["required_context"] = decision.get("required_context", [])
                    final_units.append(unit)
                else:
                    key = (decision.get("reason", "")[:40] or "llm_skip").strip()
                    llm_skips[key] = llm_skips.get(key, 0) + 1
                    logger.info(f"[初始化引擎] 单元被LLM跳过: {file_path}, 原因: {decision.get('reason', '')}")

            # 4) 统计
            total_units = len(raw_units)
            passed_units = len(final_units)
            skipped_units = total_units - passed_units
            skip_reasons = {**hard_skips, **llm_skips}

            processing_time = time.time() - start
            logger.info(f"[初始化引擎] 初始化完成: 总计={total_units}, 通过={passed_units}, 跳过={skipped_units}, 耗时={processing_time:.2f}s")
            logger.info(f"[初始化引擎] 跳过原因统计: {skip_reasons}")

            return {
                "success": True,
                "audit_units": final_units,
                "total_units": total_units,
                "passed_units": passed_units,
                "skipped_units": skipped_units,
                "skipped_reasons": skip_reasons,
                "processing_time": processing_time,
            }

        except Exception as e:
            logger.error(f"[初始化引擎] 初始化流程失败: {str(e)}")
            return {
                "success": False,
                "audit_units": [],
                "total_units": 0,
                "passed_units": 0,
                "skipped_units": 0,
                "skipped_reasons": {"initialization_error": 1},
                "processing_time": time.time() - start,
                "error": str(e),
            }

    # -------------------------
    # 上下文拉取（与 required_context 对齐）
    # -------------------------

    def get_context_for_unit(self, unit: AuditUnit) -> Dict[str, Any]:
        """
        根据 required_context 拉取上下文
        注意：此函数只拉取已支持的上下文类型（symbol/config/call_graph）
        """
        file_path = unit.get("file_path", "")
        symbol = unit.get("symbol", {}) or {}
        symbol_name = (symbol.get("name") or "").strip()

        logger.info(f"[上下文拉取] 开始为单元拉取上下文: {file_path} (symbol: {symbol_name})")

        context: Dict[str, Any] = {}

        required = unit.get("required_context", []) or []
        required = [x for x in required if x in self.ALLOWED_CONTEXT]
        logger.info(f"[上下文拉取] 需要的上下文类型: {required}")

        if "symbol" in required and symbol_name:
            logger.info(f"[上下文拉取] 拉取符号上下文: {symbol_name}")
            try:
                symbol_context = self.context_builder.get_symbol_context(file_path, symbol_name)
                if symbol_context.get("success"):
                    context["symbol"] = symbol_context.get("context")
                    logger.info(f"[上下文拉取] 符号上下文拉取成功: {symbol_name}")
                else:
                    context["symbol_error"] = symbol_context.get("error", "symbol_context_failed")
                    logger.warning(f"[上下文拉取] 符号上下文拉取失败: {symbol_name}, 错误: {context['symbol_error']}")
            except Exception as e:
                context["symbol_error"] = str(e)
                logger.error(f"[上下文拉取] 符号上下文异常: {symbol_name}, 异常: {str(e)}")

        if "config" in required:
            logger.info(f"[上下文拉取] 拉取文件配置分析: {file_path}")
            try:
                file_analysis = self.context_builder.get_file_analysis(file_path)
                if file_analysis.get("success"):
                    context["config"] = file_analysis.get("analysis")
                    logger.info(f"[上下文拉取] 文件配置分析成功: {file_path}")
                else:
                    context["config_error"] = file_analysis.get("error", "file_analysis_failed")
                    logger.warning(f"[上下文拉取] 文件配置分析失败: {file_path}, 错误: {context['config_error']}")
            except Exception as e:
                context["config_error"] = str(e)
                logger.error(f"[上下文拉取] 文件配置分析异常: {file_path}, 异常: {str(e)}")

        if "call_graph" in required and symbol_name:
            logger.info(f"[上下文拉取] 拉取调用图: {symbol_name}")
            try:
                refs = self.context_builder.search_symbol_references(symbol_name, max_results=5)
                if refs.get("success"):
                    context["call_graph"] = refs.get("references")
                    logger.info(f"[上下文拉取] 调用图拉取成功: {symbol_name}")
                else:
                    context["call_graph_error"] = refs.get("error", "refs_failed")
                    logger.warning(f"[上下文拉取] 调用图拉取失败: {symbol_name}, 错误: {context['call_graph_error']}")
            except Exception as e:
                context["call_graph_error"] = str(e)
                logger.error(f"[上下文拉取] 调用图拉取异常: {symbol_name}, 异常: {str(e)}")

        logger.info(f"[上下文拉取] 上下文拉取完成: {file_path}, 成功类型: {list(context.keys())}")
        return context


__all__ = ["InitializationEngine"]
