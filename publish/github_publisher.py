import logging
from typing import Optional, Dict, Any

from output.models import AnalysisReport
from output.report_generator import ReportGenerator

logger = logging.getLogger(__name__)


def _generate_comprehensive_report_body(final_report: Dict[str, Any]) -> str:
    """Generate GitHub review body from comprehensive workflow report."""
    lines = ["## ðŸ” WiseCodeWatchers Comprehensive Review\n"]
    
    # PR Info
    pr_info = final_report.get("pr_info", {})
    if pr_info.get("title"):
        lines.append(f"**PR:** {pr_info.get('title', 'N/A')}")
        lines.append(f"**Changes:** +{pr_info.get('additions', 0)}/-{pr_info.get('deletions', 0)} lines\n")
    
    # Summary Statistics
    logic_review = final_report.get("logic_review", {})
    security_review = final_report.get("security_review", {})
    triage_summary = final_report.get("triage_summary", {})
    cross_impact = final_report.get("cross_file_impact", {})
    
    logic_issues = logic_review.get("issues_found", 0)
    security_issues = security_review.get("issues_found", 0)
    total_issues = logic_issues + security_issues
    
    lines.append("### ðŸ“Š Summary\n")
    lines.append(f"| Metric | Value |")
    lines.append(f"|--------|-------|")
    lines.append(f"| Logic Issues | {logic_issues} |")
    lines.append(f"| Security Issues | {security_issues} |")
    lines.append(f"| **Total Issues** | **{total_issues}** |")
    
    if triage_summary.get("total_count", 0) > 0:
        lines.append(f"| Hunks Reviewed | {triage_summary.get('to_review_count', 0)}/{triage_summary.get('total_count', 0)} |")
    
    if cross_impact.get("files_analyzed", 0) > 0:
        lines.append(f"| High Impact Files | {len(cross_impact.get('high_impact_files', []))} |")
    
    lines.append("")
    
    # Logic Issues
    if logic_issues > 0:
        lines.append("### ðŸ§  Logic Issues\n")
        for issue in logic_review.get("issues", [])[:10]:
            issue_data = issue.get("issue", {})
            if issue_data:
                severity = issue_data.get("severity", "unknown").upper()
                title = issue_data.get("title", "Unknown issue")
                file_path = issue.get("_meta", {}).get("file_path", "")
                lines.append(f"- **[{severity}]** {title}")
                if file_path:
                    lines.append(f"  - File: `{file_path}`")
                desc = issue_data.get("description", "")
                if desc:
                    lines.append(f"  - {desc[:200]}...")
        if logic_issues > 10:
            lines.append(f"\n*...and {logic_issues - 10} more logic issues*")
        lines.append("")
    
    # Security Issues
    if security_issues > 0:
        lines.append("### ðŸ”’ Security Issues\n")
        for issue in security_review.get("issues", [])[:10]:
            issue_data = issue.get("issue", {})
            if issue_data:
                severity = issue_data.get("severity", "unknown").upper()
                title = issue_data.get("title", "Unknown vulnerability")
                file_path = issue.get("_meta", {}).get("file_path", "")
                cwe = issue_data.get("cwe", [])
                lines.append(f"- **[{severity}]** {title}")
                if cwe:
                    lines.append(f"  - CWE: {', '.join(cwe)}")
                if file_path:
                    lines.append(f"  - File: `{file_path}`")
        if security_issues > 10:
            lines.append(f"\n*...and {security_issues - 10} more security issues*")
        lines.append("")
    
    # Cross-file impact warnings
    breaking_changes = cross_impact.get("breaking_changes", [])
    if breaking_changes:
        lines.append("### âš ï¸ Breaking Changes Detected\n")
        for change in breaking_changes[:5]:
            lines.append(f"- {change.get('description', 'Breaking change detected')}")
        lines.append("")
    
    # Recommendation
    lines.append("### ðŸŽ¯ Recommendation\n")
    review_summary = final_report.get("review_summary", {})
    recommendation = review_summary.get("recommendation", "needs_review")
    if total_issues == 0:
        lines.append("âœ… No significant issues found. Ready to merge.")
    elif security_issues > 0:
        lines.append("ðŸ”´ **Security issues detected.** Please review and address before merging.")
    elif logic_issues > 3:
        lines.append("ðŸŸ¡ **Multiple logic issues found.** Consider reviewing before merging.")
    else:
        lines.append("ðŸŸ¢ Minor issues found. Review recommended.")
    
    lines.append("\n---\n*Generated by WiseCodeWatchers Comprehensive Workflow*")
    
    return "\n".join(lines)


class GitHubPublisher:
    def __init__(self, github_client):
        self.client = github_client
        self.report_generator = ReportGenerator()
        self._pr_files_cache = {}

    def _get_pr_files(self, repo_full_name: str, pr_number: int) -> set[str]:
        """Get set of file paths that are in the PR diff."""
        cache_key = f"{repo_full_name}#{pr_number}"
        if cache_key not in self._pr_files_cache:
            try:
                files = self.client.get_pr_files_changed(repo_full_name, pr_number)
                self._pr_files_cache[cache_key] = {f["filename"] for f in files}
            except Exception as e:
                logger.warning(f"Failed to get PR files: {e}")
                self._pr_files_cache[cache_key] = set()
        return self._pr_files_cache[cache_key]

    async def publish_review(
        self,
        report: AnalysisReport,
        as_review: bool = True,
        include_line_comments: bool = True,
    ) -> dict:
        try:
            body = self.report_generator.generate_github_review_body(report)

            if as_review:
                result = await self._publish_as_review(
                    report=report,
                    body=body,
                    include_line_comments=include_line_comments,
                )
            else:
                result = await self._publish_as_comment(
                    report=report,
                    body=body,
                )

            logger.info(f"Published review for PR #{report.pr_number}")
            return result

        except Exception as e:
            logger.error(f"Failed to publish review: {e}")
            raise

    async def _publish_as_review(
        self,
        report: AnalysisReport,
        body: str,
        include_line_comments: bool,
    ) -> dict:
        comments = []
        if include_line_comments:
            all_comments = self.report_generator.generate_line_comments(report)
            pr_files = self._get_pr_files(report.repo_full_name, report.pr_number)
            comments = [c for c in all_comments if c.get("path") in pr_files]
            logger.info(f"Filtered comments: {len(comments)}/{len(all_comments)} (files in PR: {len(pr_files)})")

        event = "COMMENT"
        if report.bug_detection.has_bugs:
            critical_count = report.bug_detection.by_severity.get("critical", 0)
            high_count = report.bug_detection.by_severity.get("high", 0)
            if critical_count > 0 or high_count > 3:
                event = "REQUEST_CHANGES"

        self.client.create_review(
            repo_full_name=report.repo_full_name,
            pr_number=report.pr_number,
            body=body,
            event=event,
            comments=comments,
        )

        return {
            "type": "review",
            "event": event,
            "body_length": len(body),
            "line_comments_count": len(comments),
        }

    async def _publish_as_comment(
        self,
        report: AnalysisReport,
        body: str,
    ) -> dict:
        self.client.create_issue_comment(
            repo_full_name=report.repo_full_name,
            pr_number=report.pr_number,
            body=body,
        )

        return {
            "type": "comment",
            "body_length": len(body),
        }

    def publish_review_sync(
        self,
        report: AnalysisReport,
        as_review: bool = True,
        include_line_comments: bool = True,
    ) -> dict:
        try:
            body = self.report_generator.generate_github_review_body(report)

            if as_review:
                comments = []
                if include_line_comments:
                    all_comments = self.report_generator.generate_line_comments(report)
                    # Filter comments to only include files actually in the PR diff
                    pr_files = self._get_pr_files(report.repo_full_name, report.pr_number)
                    comments = [c for c in all_comments if c.get("path") in pr_files]
                    logger.info(f"Filtered comments: {len(comments)}/{len(all_comments)} (files in PR: {len(pr_files)})")

                event = "COMMENT"
                if report.bug_detection.has_bugs:
                    critical_count = report.bug_detection.by_severity.get("critical", 0)
                    high_count = report.bug_detection.by_severity.get("high", 0)
                    if critical_count > 0 or high_count > 3:
                        event = "REQUEST_CHANGES"

                try:
                    self.client.create_review(
                        repo_full_name=report.repo_full_name,
                        pr_number=report.pr_number,
                        body=body,
                        event=event,
                        comments=comments,
                    )
                    return {
                        "type": "review",
                        "event": event,
                        "body_length": len(body),
                        "line_comments_count": len(comments),
                    }
                except Exception as e:
                    if "could not be resolved" in str(e) and comments:
                        logger.warning(f"Line comments failed, retrying without comments: {e}")
                        self.client.create_review(
                            repo_full_name=report.repo_full_name,
                            pr_number=report.pr_number,
                            body=body,
                            event=event,
                            comments=[],
                        )
                        return {
                            "type": "review",
                            "event": event,
                            "body_length": len(body),
                            "line_comments_count": 0,
                            "line_comments_skipped": len(comments),
                        }
                    raise
            else:
                self.client.create_issue_comment(
                    repo_full_name=report.repo_full_name,
                    pr_number=report.pr_number,
                    body=body,
                )

                return {
                    "type": "comment",
                    "body_length": len(body),
                }

        except Exception as e:
            logger.error(f"Failed to publish review: {e}")
            raise

    def publish_comprehensive_report(
        self,
        final_report: Dict[str, Any],
        pr_number: int,
        repo_full_name: str,
    ) -> dict:
        """Publish comprehensive workflow report to GitHub as a review."""
        try:
            body = _generate_comprehensive_report_body(final_report)
            
            # Determine review event based on issues
            logic_issues = final_report.get("logic_review", {}).get("issues_found", 0)
            security_issues = final_report.get("security_review", {}).get("issues_found", 0)
            
            event = "COMMENT"
            if security_issues > 0:
                event = "REQUEST_CHANGES"
            elif logic_issues > 3:
                event = "REQUEST_CHANGES"
            
            self.client.create_review(
                repo_full_name=repo_full_name,
                pr_number=pr_number,
                body=body,
                event=event,
                comments=[],
            )
            
            return {
                "type": "comprehensive_review",
                "event": event,
                "body_length": len(body),
                "logic_issues": logic_issues,
                "security_issues": security_issues,
            }
            
        except Exception as e:
            logger.error(f"Failed to publish comprehensive review: {e}")
            raise
